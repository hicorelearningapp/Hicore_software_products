[
  {
    "id": 5,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by index is a constant time operation, hence the time complexity is O(1)."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is considered the simplest to understand and implement but inefficient for large data sets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort is considered the simplest sorting algorithm to understand and implement, but it is inefficient for large data sets due to its average and worst-case time complexity of O(n^2)."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Basic Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a type of linear data structure?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Queue"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "A Tree is a non-linear data structure compared to Queue, Stack, and Linked List which are linear."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Algorithm Efficiency",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following sorting algorithms has the best worst-case time complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Merge Sort"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Merge Sort has a guaranteed time complexity of O(n log n) in all cases, making it superior in worst-case scenarios compared to Bubble Sort, Insertion Sort, and Quick Sort with worse or average-case dependent complexities."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Array Operations",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by its index is a direct operation and therefore has a time complexity of O(1), which is constant time."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Basic Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a linear data structure?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linked List"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Graph"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Stack"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Graph is not a linear data structure; it is a non-linear data structure. Arrays, linked lists, and stacks are all examples of linear data structures."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which control structure would be most appropriate for executing a block of code multiple times based on a condition?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "While Loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "If Statement"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Switch Case"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Try-Catch Block"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A while loop executes a block of code repeatedly as long as the given condition is true, making it suitable for this scenario."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is considered the simplest to understand and implement but inefficient for large data sets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort is considered the simplest sorting algorithm to understand and implement due to its straightforward comparison and swap mechanism. However, it is inefficient for large data sets with its average and worst-case time complexity of O(n^2)."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Searching Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of data structure is required for binary search to be applicable?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Unsorted Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sorted Array"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search requires a sorted array to function properly, as it repeatedly divides the search interval in half."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Hash Tables",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary operation that hash tables optimize?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Search operations"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Arithmetic operations"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Graph traversal"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Matrix manipulations"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Hash tables are designed to optimize search operations by providing an average-case complexity of O(1) for searches, inserts, and deletes."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Binary Search",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which statement is true about the complexity of binary search in a sorted array of size n?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n^2)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search repeatedly divides the search interval in half, so the time complexity is O(log n)."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Hash Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary reason for using a hash function in hash tables?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To encrypt data"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To generate unique indexes for storing keys"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase the processing time"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the storage space"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Hash functions are used in hash tables primarily to generate unique indexes where keys can be stored or accessed, which optimizes searching and insertion operations."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Merge Sort",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes the space complexity of the merge sort algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Merge sort requires additional space proportional to the array size, hence the space complexity is O(n)."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Tree Traversal",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following tree traversal methods lists the nodes in a binary tree in the order of their hierarchical levels from top to bottom?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "In-order"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Pre-order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Post-order"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Level-order"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Level-order traversal visits each level of a tree's nodes from top to bottom, which is why it lists nodes in the order of their hierarchical levels."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Control Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a type of control structure often used in programming?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Conditional"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Sequence"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Recursion"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Recursion is a technique or pattern used in programming, but it is not classified as a control structure like loops (for, while), conditionals (if, switch), or sequence."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Array Operations",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of inserting an element at the end of a dynamic array which is already filled to its capacity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Inserting an element at the end of a dynamic array which is already at capacity involves creating a new array of twice the size and copying all elements to the new array, which takes O(n) time."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Graph Algorithms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which graph algorithm would be most suitable for finding the shortest path in a weighted graph?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Depth-First Search (DFS)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Breadth-First Search (BFS)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Dijkstra's Algorithm"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Prim's Algorithm"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Dijkstra's Algorithm is specifically designed for finding the shortest path in both unweighted and weighted graphs, particularly when all edge weights are non-negative."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Sorting Algorithms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is typically implemented using a divide-and-conquer strategy?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Selection Sort"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is implemented using a divide-and-conquer strategy where the list is divided into sub-lists that are individually sorted and then merged."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Time Complexity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding the greatest common divisor (GCD) using Euclid's algorithm for two numbers a and b?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(log(min(a, b)))"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(a + b)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log(a*b))"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(a*b)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Euclid's algorithm repeatedly subtracts the smaller number from the larger one. This process effectively reduces the problem size logarithmically, leading to a time complexity of O(log(min(a, b)))."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Graph Data Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding all pairs shortest path in a graph using Floyd-Warshall algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(V^3)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(V^2)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(VE)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(E log V)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Floyd-Warshall algorithm computes the shortest paths between all pairs of vertices in a weighted graph, and the time complexity is O(V^3), where V is the number of vertices."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Time Complexity Analysis",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding the minimum element in an unsorted array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(1)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "To find the minimum element, you must examine each element in the array at least once, resulting in a linear time complexity, O(n)."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Array Operations",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of inserting an element at the beginning of an array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Inserting an element at the beginning of an array requires shifting all other elements, resulting in a time complexity of O(n)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Algorithm Efficiency",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In the context of algorithm design, which term best describes the maximum time or space required by an algorithm as a function of the size of the input data?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Average-case complexity"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Worst-case complexity"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Best-case complexity"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Amortized complexity"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Worst-case complexity describes the maximum resources an algorithm may require, and hence it is critical for understanding the upper limits of an algorithm's performance under any input."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Array Operations",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of inserting an element at the beginning of an array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Inserting an element at the beginning of an array is O(n) because it requires shifting all existing elements one position to the right."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Time Complexity Analysis",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding the greatest common divisor (GCD) of two numbers using the Euclidean algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n^2)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The Euclidean algorithm repeatedly applies the modulo operation, which reduces the size of the numbers involved at each step logarithmically. Thus, the time complexity is O(log n)."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Control Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following control structures is best suited for executing a block of code multiple times based on a condition at the end of each iteration?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "for loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "while loop"
      },
      {
        "label": "C",
        "type": "text",
        "value": "do-while loop"
      },
      {
        "label": "D",
        "type": "text",
        "value": "if-else statement"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The do-while loop is best suited for this scenario because it ensures the code block is executed at least once and then repeatedly based on a condition checked at the end of each iteration."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Tree Data Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following tree traversal strategies lists the nodes of a binary tree in ascending order for a binary search tree?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Pre-order traversal"
      },
      {
        "label": "B",
        "type": "text",
        "value": "In-order traversal"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Post-order traversal"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Level-order traversal"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In-order traversal of a binary search tree will always result in a list of nodes sorted in ascending order. This is because in in-order traversal, the left subtree (with smaller values) is visited first, then the current node, and finally the right subtree (with larger values)."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Hash Tables",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a primary advantage of using a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Fixed size"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Data sorted order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Low memory usage"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Fast data retrieval"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The primary advantage of using a hash table is fast data retrieval, generally achieving average-case constant-time complexity, O(1), for lookups."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Tree Traversal",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following tree traversal methods visits the root node before its children?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Preorder"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Inorder"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Postorder"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Level order"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Preorder traversal, the nodes are recursively visited in the order: root, left, right. This means the root node is visited before its children."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Data Structures and Algorithms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which algorithm is most suitable for dynamically making decisions on the fly and can adjust to processed input?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Dynamic Programming"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Search"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Dynamic Programming is utilized for solving complex problems by breaking them down into simpler subproblems. It is used to make decisions dynamically by considering the current input and the solutions to previously solved subproblems."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithm Efficiency",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary benefit of using a Divide and Conquer approach in algorithms?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Reduces memory usage"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Simplifies debugging"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Increases execution speed"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Improves readability of code"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Divide and Conquer algorithms break down a problem into smaller, more manageable parts, solving each part independently and combining the solutions. This often leads to faster execution times, especially for large data sets."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Array Operations",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array if the index of the element is known?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by its index is a direct operation and has a constant time complexity of O(1)."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Graph Traversal",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which graph traversal algorithm uses a queue to keep track of the next vertex to visit?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Breadth-First Search (BFS)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Depth-First Search (DFS)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Prim's Algorithm"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Kruskal's Algorithm"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Breadth-First Search (BFS) uses a queue data structure to explore vertices level by level, ensuring all vertices at the current level are explored before moving to the next level."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Algorithm Complexity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of a binary search algorithm on a sorted array of n elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(1)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search repeatedly divides the array into halves, leading to a time complexity of O(log n)."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Tree Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In a binary search tree (BST), what is the worst-case time complexity of finding a node?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In the worst case, all the nodes of a BST might be skewed to one side (left or right), forming a linear chain. In such cases, finding a node would take O(n) time."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Data Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following data structures uses a LIFO (Last In, First Out) method for managing its elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Queue"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Linked List"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Tree"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A Stack operates on a LIFO basis, meaning the last element added to the stack will be the first one to be removed."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Merge Sort",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of Merge Sort in the worst case?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n^2)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Merge Sort always divides the array into two halves and takes linear time to merge two halves. It has a time complexity of O(n log n) in all the cases (worst, average, and best) as the mergesort always divides the array into two halves and takes linear time to merge two halves."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Hash Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following scenarios is best suited for the use of a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Finding the shortest path between two nodes in a graph."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Managing user sessions where each session is uniquely identified by a session ID."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Balancing a binary search tree."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Calculating factorial of a number."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Hash tables are ideal for scenarios where quick lookup, insertion, and deletion operations based on unique keys are required, such as managing unique session IDs."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Binary Trees",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In a binary search tree (BST), what is the time complexity of finding the maximum value?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In a BST, the maximum value is found at the rightmost node, which can be reached in O(log n) time in a balanced BST."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Tree Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which type of tree guarantees that the height of the tree remains logarithmic relative to the number of elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Red-Black Tree"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Splay Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Search Tree"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Red-Black Trees are self-balancing binary search trees where the tree maintains its balance by coloring the nodes and ensuring that certain properties are met, thereby keeping the height proportional to log(n)."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Time Complexity Analysis",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given two algorithms with complexities f(n) = n^2 and g(n) = 100n log n, for which values of n does g(n) surpass f(n) in terms of lower time complexity?"
      },
      {
        "type": "formula",
        "value": "f(n) = n^2 \\text{ and } g(n) = 100n \\log n"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "For all n > 1000"
      },
      {
        "label": "B",
        "type": "text",
        "value": "For all n > 10,000"
      },
      {
        "label": "C",
        "type": "text",
        "value": "For n < 10,000"
      },
      {
        "label": "D",
        "type": "text",
        "value": "For all n > 2^10"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Solving the inequality n^2 = 100n log n using logarithmic approximations, it is found that the crossover point where g(n) begins to have a lower time complexity than f(n) is slightly above n = 2^10. Hence, for all n greater than 2^10, g(n) is more efficient."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Binary Search Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a binary search tree, if you perform an in-order traversal, which of the following sequences could represent the output for a correctly structured binary search tree?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "1, 3, 4, 6, 8, 10, 11"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10, 6, 4, 3, 8, 11, 1"
      },
      {
        "label": "C",
        "type": "text",
        "value": "11, 10, 8, 6, 4, 3, 1"
      },
      {
        "label": "D",
        "type": "text",
        "value": "1, 3, 4, 6, 11, 8, 10"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A presents a sequence that could result from an in-order traversal of a binary search tree (smallest to largest), which adheres to the left-root-right rule inherent to in-order traversals. The other sequences do not reflect the necessary ascending order."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Dynamic Arrays",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a dynamic array that doubles its size when it reaches capacity. Starting with an initial capacity of 4, how many total copies of the array are made by the time 17 elements have been added, including the initial allocation?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "2"
      },
      {
        "label": "B",
        "type": "text",
        "value": "3"
      },
      {
        "label": "C",
        "type": "text",
        "value": "4"
      },
      {
        "label": "D",
        "type": "text",
        "value": "5"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Initially, the array has a capacity of 4. After 4 elements, it doubles to 8 (first copy), and after 8 elements, it doubles to 16 (second copy). At 17 elements, it doubles again to 32 (third copy). Thus, there are three copies made after the initial allocation."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Hash Table Collision Resolution",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which collision resolution technique in hash tables does NOT require additional memory outside the initial array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Separate Chaining"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Open Addressing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Double Hashing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Rehashing"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Open addressing resolves collisions by probing, or searching through alternate locations in the array (by following a sequence determined usually by another hash function). Unlike separate chaining, it does not require additional memory for storing elements outside the initial array."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Dynamic Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a sequence, a1, a2, ..., an, the function f(i, j) represents the sum of ai, ..., aj inclusive. If f(i, j) is exactly divisible by n, count the number of possible (i, j) pairs. The sequence is [2, 4, 1, 3, 5]. What is the count of such pairs?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "2"
      },
      {
        "label": "B",
        "type": "text",
        "value": "3"
      },
      {
        "label": "C",
        "type": "text",
        "value": "4"
      },
      {
        "label": "D",
        "type": "text",
        "value": "5"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Calculate the sum for each possible (i, j) pair and check its divisibility by n. Pairs (3, 4) and (1, 5) match the criteria."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Graph Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a directed graph where each edge has a positive weight. You are given the task to find the shortest path from a source vertex to a target vertex. Which algorithm would be most appropriate if the graph contains negative weight cycles?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Dijkstra's Algorithm"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Bellman-Ford Algorithm"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Floyd-Warshall Algorithm"
      },
      {
        "label": "D",
        "type": "text",
        "value": "A* Search Algorithm"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Dijkstra's algorithm is not suitable for graphs with negative weight cycles; it fails to compute the correct shortest path. The Bellman-Ford algorithm, however, can accommodate graphs with negative weight cycles and is capable of reporting if no solution exists due to these cycles."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithmic Efficiency",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Considering an algorithm that sorts a list of integers using a divide and conquer approach with a complexity of O(n log n), which of the following modifications would most likely increase its efficiency in terms of time complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increasing the number of divisions in the divide phase"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Applying a hybrid sorting method that switches to a different algorithm for smaller subarrays"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Decreasing the threshold for recursion to a smaller size"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Using a single, fixed pivot in every division phase"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B is correct because using a hybrid sorting method, such as switching to insertion sort for small subarrays, can optimize the overall sorting process by reducing overhead and improving cache efficiency, which is especially beneficial for smaller data sets within the divide and conquer framework."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Binary Search Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a binary search tree, which of the following operations has a worst-case time complexity of O(n) when the tree degenerates into a linked list?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Insertion"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Deletion"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Searching"
      },
      {
        "label": "D",
        "type": "text",
        "value": "All of the above"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "When a binary search tree degenerates into a linked list, all operations such as insertion, deletion, and searching require traversing the list from the start to the point of interest, leading to a worst-case time complexity of O(n)."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Data Structures and Algorithm Complexity",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given an array of integers where each element represents the maximum number of steps that can be jumped going forward from that element, write the function 'minJumps(start, end)' to determine the minimum number of jumps you must take to go from the start position to the end position."
      },
      {
        "type": "formula",
        "value": "function minJumps(start, end) { // function definition }"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use a greedy approach to take the furthest reachable step at each move."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Implement a depth-first search to explore all possible paths and choose the shortest."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Apply dynamic programming to find the minimum jumps from start to end by building a jumps table."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Sort the array and linearly iterate to find the minimum jumps."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Dynamic programming is the most efficient way to solve this problem. By building a jumps table that records the minimum jumps needed to reach each index from the start, one can efficiently determine the minimum jumps needed to reach the end."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Complexity Analysis of Recursive Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a recursive algorithm that splits a problem into 5 subproblems of half the size each iteration, with a linear-time combination step. Which of the following represents the time complexity of the algorithm?"
      },
      {
        "type": "formula",
        "value": "T(n) = 5T(\\frac{n}{2}) + cn"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "formula",
        "value": "O(n^\\log_2{5})"
      },
      {
        "label": "B",
        "type": "formula",
        "value": "O(n^2)"
      },
      {
        "label": "C",
        "type": "formula",
        "value": "O(n \\log n)"
      },
      {
        "label": "D",
        "type": "formula",
        "value": "O(n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Using the Master Theorem, we find that a = 5, b = 2, and f(n) = cn. Comparing log_b(a) = log_2(5) with the polynomial degree of f(n), which is 1, log_2(5) > 1, thus the solution by the Master Theorem falls in Case 1 where T(n) = Theta(n^log_b(a))."
      }
    ]
  }
]