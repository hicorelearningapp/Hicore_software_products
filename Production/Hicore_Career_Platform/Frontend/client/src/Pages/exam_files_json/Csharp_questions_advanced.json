
  [
  {
    "id": 9,
    "topic": "C# Data Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a built-in data type in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int"
      },
      {
        "label": "B",
        "type": "text",
        "value": "float"
      },
      {
        "label": "C",
        "type": "text",
        "value": "double"
      },
      {
        "label": "D",
        "type": "text",
        "value": "superint"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "superint is not a built-in data type in C#. Common built-in data types include int, float, and double."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Class and Objects",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does the 'new' keyword do in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Declares a new variable"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Creates a new object instance"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Initializes a new array"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Starts a new method"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The 'new' keyword in C# is used to create a new object instance."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Data Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the default value of the boolean data type in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "true"
      },
      {
        "label": "B",
        "type": "text",
        "value": "false"
      },
      {
        "label": "C",
        "type": "text",
        "value": "null"
      },
      {
        "label": "D",
        "type": "text",
        "value": "0"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, the default value of a boolean data type is 'false'."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Development Tools for WPF and WinForms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which version of Visual Studio is recommended to develop WPF and WinForms applications for .NET 8.0?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Visual Studio 2019"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Visual Studio 2022 Preview"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Visual Studio 2015"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Visual Studio 2020"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "To build WPF applications and contribute features and fixes for .NET 8.0, Visual Studio 2022 Preview is required as per the latest guidelines."
      }
    ]
  },
  {
    "id": 7,
    "topic": "C# Basic Syntax",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the correct way to declare a variable in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int myVar = 100;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "myVar = 100;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "declare myVar = 100;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "variable myVar = 100;"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, variables must be declared with a type specifier, followed by an identifier name, and optionally initialized. 'int myVar = 100;' correctly declares an integer variable named myVar and initializes it to 100."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Lambda Expressions",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes lambda expressions in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "A method to structure databases"
      },
      {
        "label": "B",
        "type": "text",
        "value": "A collection of classes and interfaces"
      },
      {
        "label": "C",
        "type": "text",
        "value": "A concise way to represent anonymous methods"
      },
      {
        "label": "D",
        "type": "text",
        "value": "A protocol for network communication"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Lambda expressions provide a clear and concise way to represent anonymous methods in C#."
      }
    ]
  },
  {
    "id": 6,
    "topic": "UI Development with WinForms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tool in WinForms allows developers to design the UI by dragging and dropping controls onto a form?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Visual Studio Designer"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Control Palette"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Form Editor"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Layout Manager"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Visual Studio Designer is a feature in WinForms that offers a drag-and-drop interface, enabling easy placement and manipulation of controls on a form."
      }
    ]
  },
  {
    "id": 8,
    "topic": "C# Data Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a value type in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int"
      },
      {
        "label": "B",
        "type": "text",
        "value": "double"
      },
      {
        "label": "C",
        "type": "text",
        "value": "bool"
      },
      {
        "label": "D",
        "type": "text",
        "value": "string"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, 'string' is a reference type, not a value type. Value types include simple types (e.g., int, double, bool), enum types, struct types, and Nullable types."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Lambda Expressions in C#",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is a lambda expression in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "An anonymous function used to create delegates or expression tree types."
      },
      {
        "label": "B",
        "type": "text",
        "value": "A type of exception handling."
      },
      {
        "label": "C",
        "type": "text",
        "value": "A loop structure."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A data storage format."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Lambda expressions are anonymous functions that provide a concise way to represent an anonymous method."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Classes and Objects",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "In C#, which keyword is used to create a new instance of a class?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "class"
      },
      {
        "label": "B",
        "type": "text",
        "value": "struct"
      },
      {
        "label": "C",
        "type": "text",
        "value": "new"
      },
      {
        "label": "D",
        "type": "text",
        "value": "interface"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'new' keyword is used in C# to create a new instance of a class."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Control Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will be the output of the following C# code snippet? \nint x = 10;\nif (x > 5)\n    x += 5;\nelse\n    x -= 5;\nConsole.WriteLine(x);"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "5"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10"
      },
      {
        "label": "C",
        "type": "text",
        "value": "15"
      },
      {
        "label": "D",
        "type": "text",
        "value": "20"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Since x initially is 10, which is greater than 5, the code inside the 'if' block executes and increments x by 5. Thus, x becomes 15."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Data Types and Variables",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will be the default value of an uninitialized boolean variable in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "null"
      },
      {
        "label": "B",
        "type": "text",
        "value": "true"
      },
      {
        "label": "C",
        "type": "text",
        "value": "false"
      },
      {
        "label": "D",
        "type": "text",
        "value": "0"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, the default value of an uninitialized boolean variable is 'false'."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Data Types and Variables",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a valid C# variable declaration?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int num = 100;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "double rate = 3.14;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "char category = 'A';"
      },
      {
        "label": "D",
        "type": "text",
        "value": "boolean isActive = true;"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, the correct keyword for declaring a boolean variable is 'bool', not 'boolean'. Therefore, 'boolean isActive = true;' is not a valid declaration."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Polymorphism in C#",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What does polymorphism allow objects to do in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Change their type at runtime based on the environment."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Permanently modify their declared type."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Perform different actions based on their type and the attributes passed to their methods."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Create unlimited instances of themselves without restriction."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Polymorphism in C# allows objects to perform different actions depending on their type or the parameters passed to their methods. It enables one interface to be used for a general class of actions, and specific actions are determined by the exact nature of the situation."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Event Handling in WinForms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is the correct way to subscribe to an event in Windows Forms?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "button1.Click += new EventHandler(button1_Click);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "button1.Click.Equals(button1_Click);"
      },
      {
        "label": "C",
        "type": "text",
        "value": "button1.Click(button1_Click);"
      },
      {
        "label": "D",
        "type": "text",
        "value": "button1.Click == button1_Click;"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The correct way to subscribe to an event in Windows Forms is using the += operator along with the event handler. This adds the event handler to the invocation list for the event."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Basic Querying with LINQ",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the correct syntax to query all the items from a DbSet named 'Products' using LINQ in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "var result = from p in Products select p;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "var result = select p from Products;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "var result = Products.Select(p => p);"
      },
      {
        "label": "D",
        "type": "text",
        "value": "var result = Products.GetAll(p => p);"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Option C is correct because it uses the extension method Select() on the DbSet 'Products' with a lambda expression, which is a common method to query data in LINQ."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Encapsulation in C#",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes the concept of encapsulation in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "A programming method where the data is not hidden."
      },
      {
        "label": "B",
        "type": "text",
        "value": "A way to ensure that object data is accessible only through methods."
      },
      {
        "label": "C",
        "type": "text",
        "value": "A process of creating new classes using the syntax of existing ones."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A design pattern used for creating a single instance of a class."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Encapsulation in C# refers to the bundling of data with the methods that operate on that data. It restricts direct access to some of an object's components, which can prevent the accidental modification of data. To achieve encapsulation, data members are declared as private and can be accessed only via public methods."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Object-Oriented Programming in C#",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes the concept of encapsulation in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The ability to inherit methods from another class."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Hiding the internal state and functionality of an object and only exposing a controlled interface."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The process of translating an object-oriented model into a SQL schema."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A design pattern used to create reusable code in C#."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Encapsulation in C# refers to hiding the internal state of an object and exposing functionality only through methods, protecting the integrity of the data and the object itself."
      }
    ]
  },
  {
    "id": 8,
    "topic": "UI Controls in WinForms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a common control in WinForms?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Button"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Label"
      },
      {
        "label": "C",
        "type": "text",
        "value": "DataGrid"
      },
      {
        "label": "D",
        "type": "text",
        "value": "MediaElement"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "MediaElement is a control used in WPF for handling media. It is not available in WinForms, which uses different controls for multimedia."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Control Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will be the output of the following C# code snippet?\n\nint x = 10;\nif (x > 10)\n{\n    Console.WriteLine(\"x is greater than 10\");\n}\nelse\n{\n    Console.WriteLine(\"x is not greater than 10\");\n}"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "x is greater than 10"
      },
      {
        "label": "B",
        "type": "text",
        "value": "x is not greater than 10"
      },
      {
        "label": "C",
        "type": "text",
        "value": "No output"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Error"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The code checks if 'x' is greater than 10, which it is not since x equals 10. Therefore, the else block executes, and the output is 'x is not greater than 10'."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Event Handling in WinForms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a Windows Forms application, which method allows you to asynchronously handle events without blocking the UI thread?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Invoke()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "BeginInvoke()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "ControlThread()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "OnEventAsync()"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "BeginInvoke() is used in Windows Forms to handle events asynchronously, allowing the UI to remain responsive by not blocking the UI thread."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Data Binding in WPF",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a WPF application, which method is recommended to implement notification on property changes to ensure data binding updates the UI accordingly?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using the INotifyCollectionChanged interface"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using the ObservableCollection<T> class"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Implementing the INotifyPropertyChanged interface"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Invoking the PropertyChanged event manually"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Implementing the INotifyPropertyChanged interface allows properties of a class to notify a bound control that the property has changed, so the control can display the updated information. While ObservableCollection<T> and INotifyCollectionChanged are used for collections, they do not apply to single property changes."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Lambda Expressions and Scope",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider the following C# code snippet: int x = 10; Func<int, int> addX = y => y + x; x = 20; var result = addX(10); What is the value of result?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "10"
      },
      {
        "label": "B",
        "type": "text",
        "value": "20"
      },
      {
        "label": "C",
        "type": "text",
        "value": "30"
      },
      {
        "label": "D",
        "type": "text",
        "value": "40"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Lambda expressions capture their outer variables by reference. When 'x' is modified to 20 before invoking 'addX', the captured reference points to the new value of 'x'. Therefore, result = 10 + 20 = 30."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Polymorphism and Method Overriding",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In C#, which of the following statements is true about method overriding?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Method overriding is the example of static polymorphism."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Method overriding allows a subclass to provide a specific implementation of a method that is already provided by one of its super-classes."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Method overriding is achieved by using the 'new' keyword."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A method can be overridden simply by using the 'override' keyword as part of the method declaration in the derived class."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Method overriding allows a subclass to provide a specific implementation of a method that is already provided by one of its super-classes, which is a key feature of dynamic polymorphism, not static polymorphism as stated in option A. Option C is incorrect as 'new' keyword is used for hiding. Option D is incorrect because the 'override' keyword must also be accompanied with 'virtual', 'abstract', or 'override' in the base class method declaration."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Delegates and Multicast",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a scenario where a delegate is used to multicast several methods. If one of these methods throws an exception, what will happen to the execution of the remaining methods in the invocation list?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Execution of remaining methods will continue."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Execution of all methods stops and control is passed to the catch block if exists."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Execution of remaining methods will continue only if handled within the delegate."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The delegate will re-invoke all methods excluding the one that threw the exception."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "When a method in a delegate's invocation list throws an exception, the subsequent methods in the list will not be executed. The exception propagates back to the caller, and if not caught, it can terminate the application."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Asynchronous Programming in C#",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true when comparing 'Task.Run()' and 'Task.Factory.StartNew()' in the context of C# asynchronous programming?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "'Task.Run()' is simply a shorthand for 'Task.Factory.StartNew()' with default parameters."
      },
      {
        "label": "B",
        "type": "text",
        "value": "'Task.Factory.StartNew()' provides more control over task scheduling and configuration than 'Task.Run()'."
      },
      {
        "label": "C",
        "type": "text",
        "value": "'Task.Run()' can be used for creating long-running tasks while 'Task.Factory.StartNew()' cannot."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Both 'Task.Run()' and 'Task.Factory.StartNew()' are obsolete and replaced by 'Task.Create()'."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "'Task.Factory.StartNew()' allows for more detailed configuration of how tasks are executed, including specifying the task scheduler, cancellation tokens, and task creation options, thus providing more control compared to 'Task.Run()', which is a more simplified API suitable for most common scenarios."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Entity Framework Eager Loading",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Entity Framework, when querying an object with related data, which method ensures that related data is loaded efficiently to avoid the N+1 query problem?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using .Include() method to specify related data to be loaded along with the main query."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using .Select() method and manually specifying each field of the related data."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using .FirstOrDefault() without specifying any related data."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Using a separate query for each related object after the main query is executed."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The .Include() method allows specifying related entities to be loaded along with the main entity, thus making a single join query to the database instead of multiple queries, efficiently preventing the N+1 problem."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Optimized Queries with LINQ and Entity Framework",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When optimizing a LINQ query in Entity Framework to retrieve only specific columns from a 'Products' table that have a price greater than 50, which approach ensures that the query utilizes server-side filtering and projection effectively?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "db.Products.Where(p => p.Price > 50).Select(p => new { p.Name, p.Price }).ToList();"
      },
      {
        "label": "B",
        "type": "text",
        "value": "db.Products.Select(p => p.Name, p.Price).Where(p => p.Price > 50).ToList();"
      },
      {
        "label": "C",
        "type": "text",
        "value": "db.Products.Select(p => new { p.Name, p.Price > 50 }).ToList();"
      },
      {
        "label": "D",
        "type": "text",
        "value": "db.Products.ToList().Where(p => p.Price > 50).Select(p => new { p.Name, p.Price });"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because it correctly applies the 'Where' clause before the 'Select' projection, ensuring the filtering is performed server-side, and only the necessary columns are retrieved, enhancing performance."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Encapsulation and Access Modifiers",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In C#, what would be the accessibility of a protected internal member in a derived class that is located in a different assembly than its base class?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It is accessible from any class in the derived class's assembly."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It is not accessible outside the base class's assembly."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It is accessible only within derived classes in the same assembly as the base class."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It is accessible in any assembly, but only through instances of the derived class."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, a protected internal member is accessible within its own assembly and also from derived classes in other assemblies. Therefore, in a derived class located in a different assembly, the protected internal member of the base class is accessible from any class within the derived class's assembly."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Data Types and Variables",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What will be the output of the following C# code snippet?\n\nint a = 10;\nint b = 3;\nvar result = a / b;\nConsole.WriteLine(result);"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "3"
      },
      {
        "label": "B",
        "type": "text",
        "value": "3.33"
      },
      {
        "label": "C",
        "type": "text",
        "value": "0"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Since both a and b are integers, the division operation results in an integer division. The fractional part is discarded, and the result is 3."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Polymorphism in C#",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a base class 'Vehicle' and derived classes 'Car' and 'Bike'. If a method 'ShowDetails()' is overridden in both derived classes, which of the following statements correctly implements polymorphism to call the method on a list of mixed 'Car' and 'Bike' objects?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "foreach (Vehicle v in vehicles) { v.ShowDetails(); }"
      },
      {
        "label": "B",
        "type": "text",
        "value": "foreach (object v in vehicles) { ((Vehicle)v).ShowDetails(); }"
      },
      {
        "label": "C",
        "type": "text",
        "value": "foreach (Vehicle v in vehicles) { ShowDetails((Vehicle)v); }"
      },
      {
        "label": "D",
        "type": "text",
        "value": "foreach (Vehicle v in vehicles) { v.GetType().GetMethod('ShowDetails').Invoke(v, null); }"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because it directly calls 'ShowDetails()' on each 'Vehicle' object, utilizing polymorphism where 'Vehicle' could be an instance of 'Car' or 'Bike'. The method resolves at runtime to the correct class implementation."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Polymorphism in C#",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a scenario where you have multiple classes inheriting from a single base class in C#. If a method is declared as virtual in the base class and overridden in one but not all derived classes, what will happen when the method is called on an object of a derived class that does not override this method?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It throws a runtime exception."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It calls the method defined in the nearest base class up the hierarchy that has an override."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It results in a compile-time error."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It does nothing and returns null."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, if a method is declared as virtual and overridden in some but not all derived classes, calling this method on an object of a derived class that does not override the method will lead to the execution of the nearest override up in its inheritance chain. If no overrides are found, it executes the base class method."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Data Binding in WPF",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In WPF, what is the correct way to ensure that a property change updates the UI automatically, and which binding mode allows changes in the UI to update the data source?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Implement INotifyPropertyChanged and use TwoWay binding mode."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use DependencyProperty and set binding mode to OneWay."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Implement ObservableCollection and use OneTime binding mode."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Use RoutedEvents with TwoWay binding mode."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "To automatically update the UI when a property changes, implement the INotifyPropertyChanged interface. The TwoWay binding mode allows the UI to update the data source and vice versa."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Delegates and Method Group Conversion",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a method in C#: void Display() { Console.WriteLine('Hello'); } and a delegate declaration: delegate void DisplayDelegate(); Which statement correctly instantiates the delegate?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "DisplayDelegate del = new DisplayDelegate(Display);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "DisplayDelegate del = Display();"
      },
      {
        "label": "C",
        "type": "text",
        "value": "DisplayDelegate del = Display;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "DisplayDelegate del = delegate Display();"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, delegates can be instantiated using the method group conversion syntax without the need for explicit delegate creation with 'new'. Thus, 'DisplayDelegate del = Display;' is the correct instantiation."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Lambda Expressions and Variable Capture",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the output of the following C# code snippet if 'values' is an array of integers consisting of {1, 2, 3, 4, 5}, and 'limit' is set to 3?"
      },
      {
        "type": "text",
        "value": "var result = values.FindAll(x => x > limit).Select(x => x * 2);\nforeach (var item in result)\n{\n    Console.WriteLine(item);\n}"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "8, 10"
      },
      {
        "label": "B",
        "type": "text",
        "value": "6, 8, 10"
      },
      {
        "label": "C",
        "type": "text",
        "value": "4, 6, 8, 10"
      },
      {
        "label": "D",
        "type": "text",
        "value": "An exception is thrown"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The lambda expression 'x => x > limit' captures the variable 'limit' and uses it to filter the array. Only elements greater than 3 are selected, which are 4 and 5. These values are then multiplied by 2, resulting in 8 and 10, which are printed out."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Lambda Expressions",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following lambda expressions is valid for creating a delegate that takes two integers and returns their product?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "(int x, int y) => x * y;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "(x, y) => return x * y;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "(int x, int y) => return x * y;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "=> (x, y) { return x * y; }"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because it correctly defines a lambda expression with the specified input types and uses the expression body correctly without the 'return' keyword which is not needed in this context."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Encapsulation",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a correct way to implement encapsulation in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using private fields and providing public or protected getter/setter methods to access or modify the data."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using public fields and restricting access to them using specific methods."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Declaring all fields as protected and manipulating them only within derived classes."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Employing properties with accessors to control the visibility and accessibility of member variables."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Encapsulation in C# is typically implemented by making fields private and providing public or protected getter/setter methods or properties to manipulate these fields. Using public fields and restricting their access via methods does not provide the safety and encapsulation benefits of private fields, as public fields can still be accessed directly."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Asynchronous Programming in C#",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using the 'await' keyword in asynchronous programming in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To immediately start a new thread."
      },
      {
        "label": "B",
        "type": "text",
        "value": "To create a new asynchronous method."
      },
      {
        "label": "C",
        "type": "text",
        "value": "To pause the execution of the method until the awaited task completes."
      },
      {
        "label": "D",
        "type": "text",
        "value": "To terminate a task if it takes too long to complete."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'await' keyword is used in asynchronous programming in C# to suspend the execution of the method until the task being awaited is complete. This allows other operations to run in the meantime without blocking the main thread."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Variable Scope and Access Modifiers",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What will be the output of the following C# code snippet? int a = 10; void Display() { int a = 20; Console.WriteLine(a); } Display(); Console.WriteLine(a);"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "20, 10"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10, 20"
      },
      {
        "label": "C",
        "type": "text",
        "value": "20, 20"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10, 10"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The variable 'a' inside Display() shadows the global variable 'a'. Inside Display(), the local 'a' is printed, showing 20. Outside, the global 'a' retains its value of 10."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Entity Framework and LINQ Best Practices",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the best practice when loading related data in Entity Framework to avoid performance bottlenecks?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use eager loading for all related data."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use explicit loading selectively on access."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Always use lazy loading for all relationships."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Utilize lazy loading but preload commonly accessed relationships."
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Utilizing lazy loading while preloading commonly accessed relationships allows for optimized loading of data. It prevents the overhead of eager loading everything while avoiding the n+1 query problem commonly associated with lazy loading."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Interfaces and Abstract Classes",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a correct statement about interfaces and abstract classes in C#?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Interfaces can contain implementation of methods just like abstract classes."
      },
      {
        "label": "B",
        "type": "text",
        "value": "A class can inherit multiple interfaces but only one abstract class."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Abstract classes can contain only abstract methods."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Interfaces in C# can contain fields and constants."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B is correct as a class in C# can indeed implement multiple interfaces but can inherit from only one abstract class. Option A is incorrect because interfaces cannot contain method implementations until C# 8.0, where default implementations were allowed. Option C is incorrect as abstract classes can contain both abstract and non-abstract methods. Option D is incorrect because interfaces cannot contain fields or constants, only properties and methods."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Data Types and Operations",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What would be the result of the following C# code snippet if executed?\n\nint a = 10;\nint b = 3;\ndouble c = a / b;\nConsole.WriteLine(c);"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "3"
      },
      {
        "label": "B",
        "type": "text",
        "value": "3.333"
      },
      {
        "label": "C",
        "type": "text",
        "value": "3.0"
      },
      {
        "label": "D",
        "type": "text",
        "value": "0"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Since both 'a' and 'b' are integers, the division operation results in an integer division. The result is then implicitly converted to a double when assigned to 'c', but this does not change the fact that the division was integer-based, hence the output is 3.0."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Lambda Expressions",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a lambda expression in C# used to filter a list of integers: 'List<int> numbers = new List<int> { 1, 2, 3, 4, 5 }; var evenNumbers = numbers.FindAll(x => x % 2 == 0);'. What is the output of 'evenNumbers'?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "An empty list"
      },
      {
        "label": "B",
        "type": "text",
        "value": "List containing 1, 3, 5"
      },
      {
        "label": "C",
        "type": "text",
        "value": "List containing 2, 4"
      },
      {
        "label": "D",
        "type": "text",
        "value": "List containing 1, 2, 3, 4, 5"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The lambda expression 'x => x % 2 == 0' filters the elements of the list, returning only those that are even (where the remainder when divided by 2 is 0). Thus, it returns a list containing 2 and 4."
      }
    ]
  },
  {
    "id": 2,
    "topic": "C# Event Handling",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In C#, if you have subscribed multiple methods to an event, how is the order of method execution determined when the event is triggered?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Random order"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Alphabetical order of method names"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Order in which they were added"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Reverse order in which they were added"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In C#, the methods subscribed to an event are executed in the order in which they were added to the event."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Using Delegates",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true when using a delegate to invoke a method that has a return type of int and takes a single string parameter?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "You must always declare the delegate inside a class."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The delegate declaration must use the Func<string, int> type."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The delegate can be declared using either Func<string, int> or a custom delegate type."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Delegates cannot have return types and therefore this scenario is not possible."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Option C is correct as the delegate for a method that returns an int and takes a string can be declared using the built-in Func<string, int> delegate type or a custom delegate that matches the signature."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Data Binding in WPF",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements best describes the use of the INotifyPropertyChanged interface in a WPF application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It allows the UI to update automatically when the data context changes."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It provides a method to directly update UI controls without involving the data context."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It is used to invoke methods asynchronously from the UI thread."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It is a built-in method in the .NET Framework for memory management."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "INotifyPropertyChanged is implemented in data source classes to notify data binding clients, typically UI elements, that a property value has changed, thus allowing the UI to update automatically based on the data context changes."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Scope and Declaration",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given the following code snippet, what will be the output?\n\nint x = 10;\nvoid Display() {\n  int x = 20;\n  {\n    int x = 30;\n    Console.WriteLine(x);\n  }\n  Console.WriteLine(x);\n}\nDisplay();"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "30\n20"
      },
      {
        "label": "B",
        "type": "text",
        "value": "30\n30"
      },
      {
        "label": "C",
        "type": "text",
        "value": "20\n30"
      },
      {
        "label": "D",
        "type": "text",
        "value": "20\n20"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Inside the Display method, the inner block shadows the variable 'x' declared in the method scope with its own 'x'. Thus, the innermost 'x' (value 30) is printed first, followed by the method's 'x' (value 20)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Memory Management in C#",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In C#, what does the statement 'GC.Collect()' explicitly trigger and what is a potential downside of using it frequently?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It triggers the garbage collector to reclaim unused memory, potentially leading to frequent memory deallocation and reallocation."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It forces the program to pause, causing a sudden drop in application performance."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It cleans up managed and unmanaged resources, but can lead to memory leaks if not used properly."
      },
      {
        "label": "D",
        "type": "text",
        "value": "GC.Collect() triggers the compiler optimization process, potentially altering the execution flow of the program."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "'GC.Collect()' explicitly forces the garbage collector to run, which can indeed help in reclaiming unused memory. However, it also causes the program to pause while the garbage collection is performed, which can lead to significant performance degradation if used improperly or too frequently."
      }
    ]
  },
  {
    "id": 8,
    "topic": "C# Variable Scope",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider the following C# code snippet: \n\nint x = 10;\nvoid Adjust(){\n  int x = 20;\n  Console.WriteLine(x);\n}\nAdjust();\nConsole.WriteLine(x);\n\nWhat will be the output of this code?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "20 followed by 10"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10 followed by 20"
      },
      {
        "label": "C",
        "type": "text",
        "value": "20 followed by 20"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10 followed by 10"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The variable 'x' inside the Adjust method is a local variable with scope limited to the Adjust method itself. It shadows the outer 'x' variable, thus the method prints '20'. Outside the method, the original 'x' retains its value of '10'."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Entity Framework Performance",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Entity Framework, when dealing with performance-critical database operations, which of the following is NOT an advisable strategy to optimize LINQ queries?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using lazy loading for all data retrieval operations"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Filtering data at the server-side rather than client-side"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Selecting only the required columns instead of retrieving entire entities"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Applying 'AsNoTracking' for read-only data scenarios"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Using lazy loading for all data retrieval operations is not advisable in performance-critical situations as it can lead to the N+1 query problem, where multiple queries are executed to load related entities, severely impacting performance."
      }
    ]
  }
  ]
