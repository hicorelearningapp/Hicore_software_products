[
  {
    "id": 7,
    "topic": "Basic Concepts of Manual Testing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary goal of manual software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To automate all test cases"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To identify defects in the software"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To design software interfaces"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To deploy software systems"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The primary goal of manual testing is to identify defects in the software to ensure the product's quality."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Defect Tracking Systems",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a common feature of defect tracking systems?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Generating automatic code fixes"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Storing and managing defect reports"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Enhancing graphics in software"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Direct marketing to users"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Defect tracking systems commonly feature the ability to store and manage defect reports, which helps teams monitor, triage, and resolve defects efficiently."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Test Case Design",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of these is NOT a characteristic of a good test case?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "High complexity"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Traceability"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Repeatability"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Clear objectives"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A good test case should be simple and not complex to ensure it's easy to execute and understand."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Introduction to Quality Assurance",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary goal of Quality Assurance in software development?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To find as many bugs as possible after development"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To ensure the product meets the specified requirements"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To enhance the marketing of the product"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the cost of development"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The primary goal of Quality Assurance is to ensure that the product meets the specified requirements, ensuring reliability, performance, and error-free operation."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Equivalence Partitioning help to reduce in the process of test case design?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The number of required test cases."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The cost of software development."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The size of the software code."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The number of software developers needed."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning reduces the number of test cases by dividing input data into equivalent partitions that can be tested in a similar way, thus minimizing redundancy."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Exploratory Testing Techniques",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary focus of exploratory testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Testing as many functionalities as possible"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Following a strict set of test cases"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Simulating real user behaviors"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Generating automated test scripts"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Exploratory testing primarily focuses on simulating real user behaviors to uncover unique issues that structured testing might not reveal."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Types of Testing Environments",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which type of testing environment is specifically designed to replicate the operating conditions in which the software product will run in production?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Development environment"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Staging environment"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Testing environment"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Production environment"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A staging environment is designed to replicate the production environment as closely as possible to simulate how the software will perform under live operating conditions."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Boundary Value Testing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Boundary Value Testing focus on?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Testing at extreme ends of input domains."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Testing in the middle values of input domains."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Testing without using any input data."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Testing system performance under load."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary Value Testing specifically targets the edges of input domains, where most errors occur in software input fields."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Equivalence Partitioning divides inputs into classes that are:"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Processed in the same way by the software"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Always invalid"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Not related to each other"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Used to test the UI only"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Equivalence Partitioning, inputs are divided into classes where each class is expected to be treated similarly by the software, thereby reducing the number of test cases required."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the main goal of using Equivalence Partitioning in test case design?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To find the maximum performance capacity of the system."
      },
      {
        "label": "B",
        "type": "text",
        "value": "To ensure that all faults are found."
      },
      {
        "label": "C",
        "type": "text",
        "value": "To reduce the number of test cases and still cover maximum requirements."
      },
      {
        "label": "D",
        "type": "text",
        "value": "To validate the user interface exclusively."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning aims to reduce the number of test cases by dividing input data into valid and invalid partitions, ensuring maximum coverage with minimal cases."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Principles of Manual Testing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary goal of manual software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To automate all test cases"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To find as many defects as possible"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To improve software usability"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To document user requirements"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The primary goal of manual testing is to find as many defects as possible to ensure the software behaves as expected."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basics of Defect Reporting",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of defect reporting in software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To document the bugs found during testing for further correction"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To increase software speed"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To enhance the graphics of the software"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To market the software"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The primary purpose of defect reporting is to document the bugs found during the testing phase so that they can be analyzed and corrected, ensuring the software functions as intended."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Basics of Defect Reporting",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of defect reporting in software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To assign blame to developers"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To improve software quality by tracking bugs"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase software development time"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To document the tester's work"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The primary purpose of defect reporting is to improve software quality by providing a systematic way to track and fix bugs, not to assign blame or simply document work."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Tracking Systems",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tool is commonly used for defect tracking?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JIRA"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Microsoft Word"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Excel"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Photoshop"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JIRA is a popular tool widely used for tracking bugs and managing projects effectively."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Test Case Design",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary goal of test case design in software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To perform debugging"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To validate the code syntax"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To find as many defects as possible"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To assess software usability"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The primary goal of test case design is to create test cases that find as many defects as possible in the software under test."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Quality Audits",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes the purpose of a quality audit in quality assurance practices?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To systematically examine the quality system"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To increase product prices"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To reduce product features"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To advertise the company"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A quality audit is conducted to systematically examine the quality system of an organization, ensuring that processes adhere to planned arrangements and are implemented effectively."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Quality Assurance Processes",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of these is NOT a typical phase of a Quality Assurance plan?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Requirements analysis"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Design testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Post-release customer support"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Implementation review"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Post-release customer support is not typically considered a phase in the Quality Assurance plan; it is generally part of ongoing customer service activities."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "In Equivalence Partitioning, which type of input data is grouped together?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Inputs that are related by user roles"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Inputs that trigger the same code paths"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Inputs that have similar security requirements"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Inputs that come from similar geographic locations"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning groups inputs that cause the same set of actions within the software, meaning they trigger the same code paths."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Test Lifecycle Management",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which phase of the test lifecycle involves setting up the test environment?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Test Planning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Test Design"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Test Execution"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Test Environment Setup"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The Test Environment Setup phase specifically involves creating and preparing the environment where the actual testing will be conducted."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Equivalence Partitioning reduces the testing effort by dividing input data into which of the following?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Similar parts that can be tested with the same test cases."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Dissimilar parts that require unique test cases."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Only invalid input data types."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Only valid input data types."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning technique groups input data in such a way that each part can be tested using the same test cases, assuming that all parts will behave similarly in tests."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is Equivalence Partitioning primarily used for in test case design?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To reduce the number of test cases by dividing them into equivalence classes"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To enhance the graphical user interface"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To check the security of the application"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To optimize the database calls in the application"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning is used to reduce the number of test cases by treating all conditions in an equivalence class as a single test condition."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Version Control in Test Data Management",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Why is version control important in test data management?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To keep track of changes to test data"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To enhance the speed of data retrieval"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase data storage capacity"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the cost of data management"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Version control is crucial in test data management as it helps in tracking and managing changes to the test data, ensuring consistency and accuracy in testing."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Boundary Value Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is Boundary Value Analysis primarily used for in software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To test the performance of the application"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To find the maximum capacity of the system"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To identify errors at the edges of input domain"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To assess the security vulnerabilities"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary Value Analysis is a testing technique that involves creating test cases to examine boundaries of input domains for errors, rather than focusing on the center of the input."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Testing Environments",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a type of testing environment?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Development"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Production"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Staging"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Replication"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Replication is not typically considered a testing environment but rather a strategy used in data management for duplicating data across multiple sites."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Defect Tracking Tools",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a popular defect tracking tool?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JIRA"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Microsoft Word"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Google Sheets"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Adobe Photoshop"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JIRA is a popular defect tracking tool used in many software development projects to manage bugs and operational issues."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Test Automation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the main advantage of implementing automated testing in quality assurance?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Reduces testing time and increases test coverage"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Increases the need for manual testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Eliminates the need for a testing team"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Guarantees that the product is free of defects"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Automated testing significantly reduces the amount of time required to perform repetitive tests and increases the breadth of test coverage, thus enhancing the efficiency of the QA process."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Testing Techniques",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which testing technique involves testing individual components separately?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Integration Testing"
      },
      {
        "label": "B",
        "type": "text",
        "value": "System Testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Unit Testing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Acceptance Testing"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Unit Testing is focused on testing individual components separately to ensure they function correctly in isolation."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Defect Tracking Tools",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tool is commonly used for defect tracking in software projects?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JIRA"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Photoshop"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Excel"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Gmail"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JIRA is a popular tool used for defect tracking in software projects, helping teams to record, report, and manage bugs effectively."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Boundary Value Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a primary goal of Boundary Value Analysis in test case design?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To detect errors at the boundaries of input domain rather than in the center."
      },
      {
        "label": "B",
        "type": "text",
        "value": "To ensure maximum usability of the software."
      },
      {
        "label": "C",
        "type": "text",
        "value": "To assess the software's performance under maximum load."
      },
      {
        "label": "D",
        "type": "text",
        "value": "To evaluate the color scheme of the user interface."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary Value Analysis focuses on generating test cases at the edges of input domain where most errors occur, rather than in the center of input domain."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Equivalence Partitioning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Equivalence Partitioning is a testing technique that divides input data into which of the following?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Different partitions where each partition is assumed to behave similarly"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Only valid input data ranges"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Only invalid input data ranges"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Data that is sorted in ascending order"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning divides input data into partitions where each partition represents a set of equivalent values. The assumption is that the system will handle all values in a partition similarly, thus only one value from each partition needs to be tested."
      }
    ]
  },
  {
    "id": 2,
    "topic": "ISO Standards",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which ISO standard focuses specifically on quality management systems and is fundamental for Quality Assurance practices?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ISO 9001"
      },
      {
        "label": "B",
        "type": "text",
        "value": "ISO 14001"
      },
      {
        "label": "C",
        "type": "text",
        "value": "ISO 27001"
      },
      {
        "label": "D",
        "type": "text",
        "value": "ISO 45001"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "ISO 9001 is the international standard that specifies requirements for a quality management system (QMS), which is essential for implementing effective Quality Assurance."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Test Case Design",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the PRIMARY objective of test case design in software testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To identify software features that are functioning as per the specifications."
      },
      {
        "label": "B",
        "type": "text",
        "value": "To ensure that all requirements are met and bugs are fixed before release."
      },
      {
        "label": "C",
        "type": "text",
        "value": "To create and maintain test cases to cover all aspects of software functionality."
      },
      {
        "label": "D",
        "type": "text",
        "value": "To save time in the development process by using automated tools."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The primary objective of test case design is to systematically create test cases that cover all functional and non-functional aspects of the software to ensure its correctness, efficiency, and usability."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Equivalence Partitioning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes Equivalence Partitioning?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Dividing the input domain into classes of data from which test cases can be derived."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Testing the system's functionality by simulating multiple users."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Assessing the system's performance under maximum load."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Checking the system's behavior without executing the code."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning involves dividing the input data of a software module into partitions of equivalent data from which test cases are derived."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Test Case Design Techniques",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which technique is most suitable for testing software requirements that have complex business logic?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Boundary Value Analysis"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Decision Table Testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "State Transition Testing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Equivalence Partitioning"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Decision Table Testing is ideal for situations where different combinations of inputs can produce different outputs, which is common in complex business logic."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Types of Manual Testing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which type of manual testing involves testing an application's interface and ensures that it meets the specified requirements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Performance Testing"
      },
      {
        "label": "B",
        "type": "text",
        "value": "UI Testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Security Testing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Integration Testing"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "UI Testing is specifically designed to identify visual and interaction issues in the software's user interface, ensuring it aligns with user requirements."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Equivalence Partitioning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In manual testing, Equivalence Partitioning is used to:"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Reduce the number of test cases by grouping similar input data that should be treated the same"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Identify different output partitions to increase test coverage"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Execute test cases until the software component fails"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Test the system's response time under high load"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence Partitioning reduces the total number of test cases by grouping similar input data that should behave similarly, thereby streamlining the testing process."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Data Anonymization Techniques",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which data anonymization technique can directly mask personal identifiers without altering the data format?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Pseudonymization"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Data scrambling"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Data shuffling"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Generalization"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Pseudonymization is a technique where personal identifiers are replaced with artificial identifiers, allowing the data format to remain unchanged while ensuring anonymity."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Defect Tracking Tools",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a common feature of defect tracking tools?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Generating automated test scripts"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Prioritization of bugs"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Tracking bug status"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Assigning bugs to team members"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Defect tracking tools are designed to manage and track the status of defects, prioritize them, and assign them to team members. They do not typically generate automated test scripts, which is usually a feature of separate testing software."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Boundary Value Analysis",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In Boundary Value Analysis (BVA), which of the following is a key reason to test boundary values?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Boundary values are less likely to cause system errors."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Boundary values are more prone to having defects."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Boundary values are easier to calculate than other values."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Boundary values cover the entire range of input values."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary values are often error-prone as developers might overlook conditions at the boundaries. BVA specifically targets these areas to ensure robustness at the edges of input ranges."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Testing Environments Setup",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a common characteristic of a sandbox testing environment?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Isolation from production systems"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Ability to simulate real user interactions"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Full access to live production data"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Controlled testing conditions"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Sandbox environments are typically isolated from production environments and do not have full access to live production data to prevent any potential data breaches and ensure the integrity of the production systems."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Bug Life Cycle",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following best describes the 'Resolved' status in a typical bug life cycle?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The developer has fixed the bug, and it is ready for the next release."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The tester has retested and closed the bug as no longer reproducible."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The bug has been fixed, and it is awaiting verification by a tester."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The bug report has been created but not yet assigned."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'Resolved' status indicates that the developer believes the bug is fixed and it is now pending verification by a tester to confirm the resolution before it can be closed."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Boundary Value Analysis",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In boundary value analysis, how should a manual tester approach a scenario where the input range is defined from 1 to 1000?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Test with values 0, 1, 1000, and 1001 only"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Test with values 1, 500, and 1000 only"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Test with every value from 1 to 1000"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Test with values 0, 1, 999, 1000, and 1001"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary value analysis involves testing at the boundaries between partitions. Thus, testing should include the values just outside the boundaries (0 and 1001) and just inside the boundaries (1 and 1000), as well as a near-boundary value (999)."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Equivalence Partitioning",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following scenarios best illustrates the application of equivalence partitioning in test case design?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Dividing the input domain of a password field into valid and invalid partitions based on length."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Testing a calculator app by checking addition with only positive numbers."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using boundary value analysis for a field accepting values from 1 to 100."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Creating a test case for every possible input of a Boolean function."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because it effectively utilizes equivalence partitioning by categorizing input data into groups (partitions) that are expected to exhibit similar behavior, thus minimizing the number of test cases while maintaining coverage."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Boundary Value Analysis",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When performing boundary value analysis on a software system that accepts integer input from 1 to 100, which set of values is most appropriate to test for an off-by-one error?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "0, 1, 100, 101"
      },
      {
        "label": "B",
        "type": "text",
        "value": "1, 50, 100"
      },
      {
        "label": "C",
        "type": "text",
        "value": "1, 99, 100"
      },
      {
        "label": "D",
        "type": "text",
        "value": "-1, 0, 101, 102"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary value analysis targets the edges of input ranges. Testing values 0 and 101 checks immediately outside the valid range (1-100), and 1 and 100 verify the boundaries themselves."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Equivalence Partitioning",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In equivalence partitioning, why is it critical to test one representative value from each partition of the input domain, especially in a complex payroll system?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It ensures all edge cases are tested thoroughly."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It minimizes the number of tests while ensuring coverage of all functional paths."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It helps in confirming the user interface elements only."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It maximizes the stress on the system to test performance."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Equivalence partitioning divides the input data into partitions from which one representative is tested. This approach reduces testing time and cost by minimizing the number of necessary tests while still covering all potential input scenarios that could affect software behavior, crucial in complex systems like payroll."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Equivalence Partitioning",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given an input domain for a password validation system ranging from 5 to 15 characters inclusive, using Equivalence Partitioning, how many valid partitions should be considered?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "One"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Two"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Three"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Four"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The valid partitions are two: one for the range 5-15 characters, and another for invalid inputs outside this range (less than 5 or more than 15 characters)."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Test Case Prioritization",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following factors is LEAST likely to influence the prioritization of test cases in a typical software development lifecycle?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The criticality of the software features"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The personal preference of the testing team"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The complexity of the code"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The business impact of potential defects"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "While the personal preference of the testing team can impact test case prioritization, it is generally considered the least professional and systematic approach compared to factors like software criticality, code complexity, and potential business impacts of defects."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Defect Lifecycle Management",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In the context of defect lifecycle management, which of the following is NOT a common state for a defect?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Resolved"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Rejected"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Deferred"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Ignored"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "While defects can be resolved, rejected, or deferred, 'Ignored' is not commonly recognized as an official state in defect lifecycle management. Typically, all defects are addressed in some manner."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Boundary Value Analysis",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a function that accepts an integer input from 1 to 100, which of the following sets of input values best represents the Boundary Value Analysis technique?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "0, 1, 100, 101"
      },
      {
        "label": "B",
        "type": "text",
        "value": "1, 50, 100"
      },
      {
        "label": "C",
        "type": "text",
        "value": "25, 50, 75"
      },
      {
        "label": "D",
        "type": "text",
        "value": "0, 50, 100"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Boundary Value Analysis involves testing at the boundaries between partitions. Here, 0 and 101 are just outside the valid input range (1-100), and 1 and 100 are the boundaries of the valid input range."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Equivalence Partitioning",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In equivalence partitioning, which of the following is a primary reason for dividing input data into equivalent partitions?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To ensure each partition is mutually exclusive and collectively exhaustive"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To minimize the total number of test cases"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To maximize software performance"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To simplify the code review process"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Dividing input data into equivalent partitions ensures that each partition is mutually exclusive and collectively exhaustive, which means no overlap between partitions and all possible inputs are covered by some partition. This approach systematically reduces the number of test cases needed while maintaining effective coverage."
      }
    ]
  }
]