[
  {
    "id": 8,
    "topic": "Node.js Package Manager",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the default package manager for Node.js?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "NPM"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Yarn"
      },
      {
        "label": "C",
        "type": "text",
        "value": "NuGet"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Bower"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "NPM stands for Node Package Manager, and it is the default package manager for Node.js."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Connecting to MongoDB with Mongoose",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What function is used in Mongoose to connect to a MongoDB database?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "mongoose.connect()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "mongoose.connection()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "mongoose.open()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "mongoose.start()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "mongoose.connect() is the correct function to establish a connection between Mongoose and a MongoDB database."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Basic MongoDB Operations",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method is used to find one document in a MongoDB collection?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "findOne()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "findSingle()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "searchOne()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "getOne()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The findOne() method is used to find the first document that matches the query."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Routing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What method would you use to handle a GET request in Express.js?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "app.get()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "app.post()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "app.put()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "app.delete()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "app.get() is used to handle GET requests in Express.js, allowing the server to read data."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic MongoDB Commands",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which command is used to create or switch to a new database in MongoDB?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "use <database_name>"
      },
      {
        "label": "B",
        "type": "text",
        "value": "create <database_name>"
      },
      {
        "label": "C",
        "type": "text",
        "value": "new <database_name>"
      },
      {
        "label": "D",
        "type": "text",
        "value": "switch <database_name>"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The 'use <database_name>' command is used in MongoDB to create a new database if it doesn't exist, or switch to the specified database if it does."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Node.js File System Module",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method in the File System module is used to read the contents of a file?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "fs.readFile()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "fs.writeFile()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "fs.appendFile()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "fs.readURL()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "fs.readFile() is the correct method to asynchronously read the entire contents of a file."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Load Balancing in Node.js",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which Node.js module is primarily used for load balancing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Express"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Cluster"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Async"
      },
      {
        "label": "D",
        "type": "text",
        "value": "PM2"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The Cluster module allows you to easily create child processes that all share server ports, aiding in load balancing."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Node.js Basics",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is Node.js primarily used for?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Data analysis"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Developing desktop applications"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Back-end server development"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Mobile app development"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Node.js is primarily used for back-end server development due to its asynchronous, event-driven architecture."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Process Managers",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tool is used to keep a Node.js application running continuously and to restart it after a crash or server restart?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Webpack"
      },
      {
        "label": "B",
        "type": "text",
        "value": "PM2"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Gulp"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Nodemon"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "PM2 is a popular process manager for Node.js applications that keeps the application running continuously and automatically restarts it if it crashes."
      }
    ]
  },
  {
    "id": 10,
    "topic": "NPM Fundamentals",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary function of the command 'npm init'?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To update a package"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To uninstall a package"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To initialize a new Node.js project"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To list installed packages"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'npm init' command is used to create a new package.json file in the root of a Node.js project, initializing a new project."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Event Loop and Non-blocking I/O",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Consider a Node.js environment. Which of the following statements is true regarding the execution sequence of setTimeout and setImmediate?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "setTimeout always executes before setImmediate."
      },
      {
        "label": "B",
        "type": "text",
        "value": "setImmediate always executes before setTimeout."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The execution order of setTimeout and setImmediate can vary depending on the context they are called within."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Neither setTimeout nor setImmediate will execute if they are called outside of any I/O cycle."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The execution order between setTimeout and setImmediate is not guaranteed and can vary. If called within an I/O cycle, setImmediate is designed to execute before any additional input/output events (including timers) if scheduled within an I/O callback."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Routing in Express.js",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which method would you use in Express.js to handle a POST request at the route '/submit-form'?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "app.get('/submit-form', callback);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "app.post('/submit-form', callback);"
      },
      {
        "label": "C",
        "type": "text",
        "value": "app.put('/submit-form', callback);"
      },
      {
        "label": "D",
        "type": "text",
        "value": "app.all('/submit-form', callback);"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "To handle a POST request specifically, you would use the app.post() method, specifying the route and the callback function to execute."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Routing in Express.js",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which method would you use to handle a POST request to the '/submit' route in Express.js?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "app.get('/submit', callback)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "app.post('/submit', callback)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "app.use('/submit', callback)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "app.all('/submit', callback)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "To handle a POST request to the '/submit' route in Express.js, you should use the app.post method. This method is specifically designed to handle POST requests."
      }
    ]
  },
  {
    "id": 10,
    "topic": "MongoDB Indexes",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using indexes in MongoDB?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To decrease the storage space used by the database"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To increase the performance of query operations"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To add more security features to the database"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To facilitate replication and backup processes"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Indexes in MongoDB are primarily used to enhance the performance of query operations by efficiently locating the data without scanning every document in a collection."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Mongoose Schema Types",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which Mongoose Schema type is used to store an array of string values?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "[String]"
      },
      {
        "label": "B",
        "type": "text",
        "value": "String[]"
      },
      {
        "label": "C",
        "type": "text",
        "value": "{ type: Array }"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Array<String>"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Mongoose, to declare a Schema type that holds an array of strings, [String] is used. This indicates an array where each element is a String."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Scaling",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In a microservices architecture with Node.js, what does the term 'Horizontal scaling' refer to?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Adding more resources to a single node"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Reducing the resources used by a single node"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Adding more nodes to the pool of resources"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Combining multiple nodes into a single node"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Horizontal scaling refers to adding more nodes to the existing pool of resources to handle increased load, rather than increasing the capacity of a single node."
      }
    ]
  },
  {
    "id": 6,
    "topic": "MongoDB Indexing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a direct benefit of indexing in MongoDB?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increased write performance"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Reduced response time for queries"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Efficient execution of queries"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Effective use of RAM for query data"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Indexing primarily enhances reading speed and query performance, but it can actually decrease write performance since each write operation also has to update the indexes."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Node.js Modules",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the default scope for Node.js modules?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Global"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Local to each module"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Local to each function"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Global to all modules"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B is correct because in Node.js, modules are encapsulated and can only expose their functionality to other modules if explicitly asked to do so, indicating a local scope."
      }
    ]
  },
  {
    "id": 8,
    "topic": "MongoDB Indexing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which type of MongoDB index would be most efficient for sorting documents based on a field that frequently changes its value?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Compound Index"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Single Field Index"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Hashed Index"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Geospatial Index"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A Single Field Index is most efficient for sorting documents based on a frequently changing field, as it minimizes the overhead associated with updating compound or specialized indexes."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Load Balancing in Node.js",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which load balancing strategy improves the performance and availability of applications by distributing incoming network traffic across multiple servers?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Round-robin DNS"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Vertical clustering"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Horizontal scaling"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Weighted routing"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Round-robin DNS is a simple method to distribute client requests across a group of servers, ensuring no single server bears too much demand."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Modules and Require System",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "If a cyclic dependency occurs in Node.js, where module A depends on module B, and module B in turn depends on module A, what will the exported value of module A be when it is required in module B?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The initial export of module A prior to any modification"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The final export of module A after all modifications"
      },
      {
        "label": "C",
        "type": "text",
        "value": "null"
      },
      {
        "label": "D",
        "type": "text",
        "value": "undefined"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In case of a cyclic dependency, Node.js will return the exports of module A as it is at the time module B requires it, which is typically its state before any modifications made during runtime."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Advanced Routing with Express.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Express.js, how can you ensure that a specific middleware function is executed conditionally only when a certain route parameter is present in the URL?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use app.use() with a conditional statement inside the middleware function."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use router.param() to define middleware specific to a parameter."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Define the middleware directly inside the route handling function."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Use a regular expression to match the route and execute middleware conditionally."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B is correct because router.param() allows you to manage middleware when a specific route parameter is identified, providing a clean and efficient way to run conditional logic based on the presence of route parameters."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Indexing in MongoDB",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When utilizing compound indexes in MongoDB, what is the impact of field order in the index on query performance?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Field order in the index does not affect query performance."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Field order can significantly affect query performance by determining whether the index can be used for sorting."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Field order impacts only write performance, not read performance."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Field order affects the size of the index but not query performance."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The order of fields in a MongoDB compound index is crucial as it determines the types of queries the index can efficiently support. It affects whether the index can be used not only for filtering but also for sorting operations."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Promises and Async/Await",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Node.js, what is the impact of incorrectly handling a rejected promise returned from an async function?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It leads to a memory leak"
      },
      {
        "label": "B",
        "type": "text",
        "value": "It can cause an unhandled promise rejection"
      },
      {
        "label": "C",
        "type": "text",
        "value": "It increases the application's performance"
      },
      {
        "label": "D",
        "type": "text",
        "value": "It has no impact, as Node.js handles it internally"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Not properly handling a rejected promise from an async function can lead to 'unhandled promise rejection', risking application crashes or unexpected behaviors."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Load Balancing in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which load balancing technique allows Node.js applications to optimize resource usage, avoid overload, and ensure high availability, especially under a microservices architecture?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Round-robin DNS load balancing"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Server-Side Session load balancing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Client-Side Load Balancing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "IP Hash load balancing"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Round-robin DNS load balancing allows the distribution of client requests across multiple servers, ensuring no single server bears too much load which is essential in microservices architecture."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Node.js Native Modules",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which native Node.js module provides utilities for working with file paths?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "http"
      },
      {
        "label": "B",
        "type": "text",
        "value": "url"
      },
      {
        "label": "C",
        "type": "text",
        "value": "path"
      },
      {
        "label": "D",
        "type": "text",
        "value": "fs"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'path' module provides utilities for working with file and directory paths. It is a native module in Node.js, used to handle and transform file paths across different operating systems."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Node.js Streams",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a readable stream 'readStream' and a writable stream 'writeStream', how would you handle backpressure correctly in Node.js?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "readStream.pipe(writeStream);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "readStream.on('data', (chunk) => { if (!writeStream.write(chunk)) { readStream.pause(); writeStream.once('drain', readStream.resume); } });"
      },
      {
        "label": "C",
        "type": "text",
        "value": "readStream.on('readable', () => { let data; while (null !== (data = readStream.read())) { writeStream.write(data); } });"
      },
      {
        "label": "D",
        "type": "text",
        "value": "writeStream.write(readStream.read());"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B correctly handles backpressure by pausing the read stream when the write stream's buffer is full, and resuming the read stream once the 'drain' event is emitted from the write stream."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Event-driven Asynchronous Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a valid method to handle errors in an asynchronous non-blocking I/O operation in Node.js?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using the async/await syntax along with try/catch blocks"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using the EventEmitter class to emit 'error' events"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Passing a callback function with an error parameter to handle possible errors"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Injecting an IIFE (Immediately Invoked Function Expression) to handle the error synchronously"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Option D is incorrect because injecting a synchronous IIFE in an asynchronous operation to handle errors disrupts the non-blocking nature of Node.js operations."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Event Loop Utilization in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Node.js, why might using too many synchronous operations inside callbacks lead to poor performance?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It can cause memory leaks over time"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Synchronous operations can block the event loop, leading to delayed processing of other asynchronous operations"
      },
      {
        "label": "C",
        "type": "text",
        "value": "It increases CPU utilization unnecessarily"
      },
      {
        "label": "D",
        "type": "text",
        "value": "It increases the load on the garbage collector"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Synchronous operations within callbacks can block the event loop. Since Node.js is essentially single-threaded, blocking the event loop prevents the system from processing other asynchronous callbacks, leading to increased response times and poor performance."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Advanced Mongoose Schema",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Mongoose, when defining a schema, what does the 'set' property in a schema type do?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It sets default values for the document."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It modifies the input value of the property before saving."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It specifies a pre-save validation rule."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It locks the schema to prevent further modifications."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The 'set' property in a Mongoose schema type is a custom setter modifier which modifies the input value of the property before it is saved to the database."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Load Balancing in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which load balancing strategy would be most effective for a Node.js application handling compute-intensive tasks that are unevenly distributed among users?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Round Robin"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Least Connection Method"
      },
      {
        "label": "C",
        "type": "text",
        "value": "IP Hash"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Resource-Based Balancing"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Resource-Based Balancing is most effective for compute-intensive tasks as it considers the server load and capacity, distributing tasks based on resource availability rather than just connection counts or sessions."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Horizontal Scaling with Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a horizontally scaled Node.js application, what is the primary method to ensure session persistence across multiple server instances?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Client-side sessions"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sticky sessions"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Load balancer configuration"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Distributed cache mechanism"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Sticky sessions ensure that a user's session is bound to a specific server instance, thereby maintaining session persistence across multiple servers in a horizontally scaled environment."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Event Loop and Non-blocking I/O",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the consequence of blocking the Node.js event loop with CPU-intensive operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Improves performance by utilizing multiple CPU cores"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Causes an increase in the memory usage of the application"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Leads to delays in processing I/O operations, degrading application responsiveness"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Has no significant impact as Node.js automatically manages CPU-intensive tasks"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Blocking the event loop in Node.js with CPU-intensive tasks prevents it from handling other asynchronous non-blocking operations, leading to delays in I/O operations and affecting the responsiveness of the application."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Event Loop Utilization in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What effect does using the setImmediate() function have on Node.js\u2019 event loop compared to setTimeout() with a delay of 0?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "setImmediate() is processed at the beginning of the next event loop phase."
      },
      {
        "label": "B",
        "type": "text",
        "value": "setImmediate() and setTimeout(0) are processed at the same time in the event loop."
      },
      {
        "label": "C",
        "type": "text",
        "value": "setImmediate() is processed after any I/O events but before setTimeout(0)."
      },
      {
        "label": "D",
        "type": "text",
        "value": "setTimeout(0) is processed before setImmediate() in the check phase."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "setImmediate() callbacks are executed after I/O events but before setTimeout() and setInterval() callbacks that have a delay of 0 ms. This means they are prioritized differently in the event loop phases."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Error Handling in Asynchronous Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is a potential issue when using 'uncaughtException' as an error-handling strategy in Node.js applications?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It may lead to memory leaks"
      },
      {
        "label": "B",
        "type": "text",
        "value": "It only logs errors to the console"
      },
      {
        "label": "C",
        "type": "text",
        "value": "It restarts the Node.js process automatically"
      },
      {
        "label": "D",
        "type": "text",
        "value": "It can only handle syntax errors"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Using 'uncaughtException' can lead to memory leaks since it handles exceptions without shutting down the process, potentially leaving resources incorrectly allocated."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Node.js Version Management",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which tool enables the use of multiple Node.js versions on a single system without affecting globally installed packages specific to each version?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "NVM (Node Version Manager)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Node Package Manager"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Webpack"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Babel"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "NVM allows you to run multiple versions of Node.js concurrently on the same machine, each with its own set of global packages, thereby avoiding version conflicts."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Environment Variables in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the correct method to set and use environment variables securely in a Node.js application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Storing variables in a .env file and accessing via process.env"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Storing variables directly in the code"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Hard-coding variables in a JSON file"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Using global variables"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Storing sensitive variables in a .env file and accessing them through process.env is a secure method as it keeps the data out of source control."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Load Balancing Techniques",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In the context of Node.js applications, which load balancing technique allows session persistence necessary for sticky sessions?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Round Robin DNS"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Least Connections"
      },
      {
        "label": "C",
        "type": "text",
        "value": "IP Hash"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Random Choice"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "IP Hash technique is utilized for load balancing where the same client IP address will always reach the same server. This is crucial for session persistence in applications that need sticky sessions."
      }
    ]
  },
  {
    "id": 4,
    "topic": "NPM Version Management",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What command would you use in npm to ensure that all dependencies of a project are restored to their exact versions as specified in the package-lock.json?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "npm install --save"
      },
      {
        "label": "B",
        "type": "text",
        "value": "npm update"
      },
      {
        "label": "C",
        "type": "text",
        "value": "npm ci"
      },
      {
        "label": "D",
        "type": "text",
        "value": "npm install --no-save"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "npm ci (clean install) is a command that installs dependencies directly from the package-lock.json file, ignoring the package.json, and thereby ensuring exact versions of all dependencies are installed."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Event Emitter",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Node.js, which of the following statements is true when using the 'removeListener' method with EventEmitters?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It removes all listeners for all events when no arguments are passed."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It can remove a specific listener by passing the event name and the listener function."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It throws an error if the specified listener is not found for the event."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It returns the emitter so multiple calls can be chained together."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The 'removeListener' method in Node.js EventEmitters is used to remove a specific listener from an event. It requires both the event name and the reference to the listener function that was added previously with 'on' or 'addListener'."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Event Loop and Non-blocking I/O",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the result of executing setTimeout with a delay of 0 ms in the Node.js event loop?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It executes the callback function immediately."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It places the callback function at the end of the current phase of the event loop."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It executes after the poll phase regardless of the set delay."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It queues the callback to run after the next tick of the event loop."
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Setting setTimeout with a delay of 0 ms doesn't mean it executes immediately but rather queues it to run after the current operation completes, effectively after the next tick of the event loop."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Node.js Version Management",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which tool allows you to run multiple versions of Node.js concurrently, and is built specifically for production environments?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "nvm"
      },
      {
        "label": "B",
        "type": "text",
        "value": "n"
      },
      {
        "label": "C",
        "type": "text",
        "value": "docker"
      },
      {
        "label": "D",
        "type": "text",
        "value": "nodebrew"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Docker allows running multiple versions of Node.js concurrently by containerizing each version, making it suitable for production environments."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Error Handling in Asynchronous Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the appropriate strategy to handle errors in Node.js when using the async/await syntax?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using a try/catch block surrounding the await statements"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using .catch() method at the end of each promise"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using process.on('uncaughtException', handler)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Errors in async/await cannot be caught or handled"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In the async/await syntax, the try/catch block is used to catch and handle errors directly around asynchronous operations which is more intuitive than attaching a .catch() method to each promise."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Middleware in Express.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Considering an Express.js application, which of the following is true when implementing asynchronous middleware that performs I/O operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The middleware must return a Promise to handle the completion of the I/O operations."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Asynchronous operations in middleware do not affect the request-response cycle."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The next() function should be called before the asynchronous operation completes."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Error handling for asynchronous operations in middleware should be managed using try/catch blocks within the middleware function."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Asynchronous middleware in Express.js should return a Promise to ensure that the server waits for the completion of all I/O operations before moving to the next middleware or ending the response. This avoids unhandled errors and incomplete operations affecting the application's stability."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Scaling Node.js Applications",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a recommended practice for optimizing Node.js application performance during scaling?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Implementing clustering"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using process managers like PM2"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Frequent synchronous I/O operations"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Caching frequently accessed data"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Frequent synchronous I/O operations can block the Node.js event loop, leading to decreased performance. Asynchronous I/O should be used to prevent blocking and optimize performance during scaling."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Advanced Querying in MongoDB",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which MongoDB operation allows you to transform document shapes, perform joins, and include computed fields in a single query?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "aggregate()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "find()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "update()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "mapReduce()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The aggregate() function in MongoDB allows for complex querying, transformations, and computations, which is not directly possible with find(), update(), or mapReduce()."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Node.js Global vs Local Installation",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a Node.js project, installing a package locally rather than globally ensures which of the following?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The package can be controlled via environmental variables."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The package does not interfere with other projects."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The package automatically updates with Node.js."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The package increases system-wide security vulnerabilities."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Installing a package locally within a project ensures that the package and its dependencies are isolated to that project, avoiding conflicts with other projects that might require different versions."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Handling Race Conditions in Node.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Node.js, if two async functions are accessing and modifying the same resource simultaneously, which technique can be effectively used to prevent race conditions?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using the async.waterfall method"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Implementing mutex locks"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Utilizing the Event Emitter pattern"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Applying the singleton pattern"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Mutex locks help manage race conditions by ensuring that only one async function can access the resource at a time, preventing simultaneous modifications."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Node.js Core Modules",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which core Node.js module method is used to monitor changes in the file system but does not work recursively for all operating systems?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "fs.watch()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "fs.watchFile()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "fs.readFile()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "fs.createReadStream()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "fs.watch() is used to monitor changes in the file system. However, it does not support recursive watching in all operating systems, such as Linux."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Error Handling in Express.js",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the best practice for structuring an asynchronous error handling middleware in Express.js to catch errors from both synchronous and asynchronous operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use try-catch blocks inside all middleware and manually pass errors to next()."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use a centralized error handling middleware with async-await and try-catch blocks."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Only use next() for asynchronous operations and throw for synchronous."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Wrap all middleware functions with a higher-order function that handles errors."
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Option D is correct because wrapping middleware functions with a higher-order function that intercepts and handles errors ensures that both synchronous and asynchronous errors are caught and processed appropriately, simplifying error management across the application."
      }
    ]
  }
]