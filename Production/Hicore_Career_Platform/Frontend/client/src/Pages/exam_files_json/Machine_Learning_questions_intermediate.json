[
  {
    "id": 7,
    "topic": "Supervised Learning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the main goal of supervised learning in machine learning?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To cluster data into similar groups"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To generate new data based on patterns"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To learn a model that can make predictions based on known labels"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the dimensionality of data"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In supervised learning, the algorithm learns from a training dataset that includes inputs and the corresponding correct outputs, and uses this learned model to predict outputs for new inputs."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Basic Concepts",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "In machine learning, what does 'feature' typically refer to?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "An individual measurable property or characteristic of a phenomenon being observed."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The algorithm used for processing data."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The result of a clustering algorithm."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A type of machine learning model."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In the context of machine learning, a 'feature' refers to an individual measurable property or characteristic of a phenomenon being observed."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Tokenization",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does the process of tokenization achieve in natural language processing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Breaking text into sentences or words"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Translating text from one language to another"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Correcting grammatical errors in the text"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Encrypting the text data"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Tokenization is the process of breaking down text into smaller components like words or sentences, which is crucial for further processing in NLP."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Tokenization",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of tokenization in natural language processing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To split text into paragraphs"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To split text into sentences or words"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To convert text into binary code"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To check the grammar of the text"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Tokenization is the process of breaking down text into smaller components like words or phrases, allowing for easier processing in NLP tasks."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Types of Learning",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which type of learning algorithm requires labeled data?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Supervised Learning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Unsupervised Learning"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Reinforcement Learning"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Semi-supervised Learning"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Supervised learning algorithms require labeled data to train the model, as the model learns to predict outcomes based on provided input-output pairs."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Stemming and Lemmatization",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which process more accurately captures the semantic root of a word?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Tokenization"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Stemming"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Lemmatization"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Vectorization"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Lemmatization considers the context and converts the word to its meaningful base form, whereas stemming simply removes the last few characters, often leading to incorrect meanings and spelling errors."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Understanding Random Forests",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is a key benefit of using a Random Forest algorithm compared to a single decision tree?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It is computationally less intensive"
      },
      {
        "label": "B",
        "type": "text",
        "value": "It has a simpler structure"
      },
      {
        "label": "C",
        "type": "text",
        "value": "It reduces the risk of overfitting"
      },
      {
        "label": "D",
        "type": "text",
        "value": "It requires less data to train"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Random Forests reduce the risk of overfitting by averaging multiple decision trees, which individually may overfit the data."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Basics of Decision Trees",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using decision trees in machine learning?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To cluster data into similar groups"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To visualize data"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To predict the outcome based on certain input variables"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To calculate statistical means and medians"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Decision trees are a type of supervised learning algorithm that are used primarily for classification and regression tasks which predict the outcome based on input variables."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Hyperplane Margins",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "In the context of Support Vector Machines, what is the main purpose of maximizing the margin around the hyperplane?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To minimize computational resources"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To maximize prediction accuracy"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase model complexity"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To improve generalization to new data"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Maximizing the margin around the SVM hyperplane helps in improving the model's generalization capabilities to new data, thereby reducing overfitting."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Activation Functions",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which activation function introduces non-linearity without expiring the gradient?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ReLU"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sigmoid"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Tanh"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linear"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "ReLU (Rectified Linear Unit) introduces non-linearity while helping to avoid the problem of vanishing gradients, unlike Sigmoid and Tanh."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Feature Importance in Random Forests",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which method does not contribute to determining feature importance in a trained random forest model?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Gini impurity decrease"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Permutation feature importance"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Out-of-bag error"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Bootstrap aggregating"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Bootstrap aggregating, or bagging, is a technique for reducing variance in random forest models, not for assessing feature importance."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Sequence Modeling",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which model is particularly useful for handling sequences in data, such as time series or text?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Convolutional Neural Network (CNN)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Random Forest"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Recurrent Neural Network (RNN)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Support Vector Machines (SVM)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Recurrent Neural Networks (RNNs) are designed to work with sequence prediction problems by maintaining a \u2018memory\u2019 of previous inputs in their network's neurons, making them ideal for tasks involving sequences like time series or text."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Backpropagation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of the backpropagation algorithm in training neural networks?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To adjust the weights of the network to minimize the loss function"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To increase the speed of the training process"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To prevent overfitting during training"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To initialize the weights of the network"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Backpropagation adjusts the weights in a neural network by calculating the gradient of the loss function and using it to update the weights, effectively minimizing the loss."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Activation Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which activation function would you generally use for the output layer in a neural network model for binary classification?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ReLU"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sigmoid"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Softmax"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Tanh"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Sigmoid activation function is typically used for binary classification as it outputs probabilities in range between 0 and 1."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Classification of Learning Algorithms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which learning algorithm requires labeled data to train the model?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Supervised learning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Unsupervised learning"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Reinforcement learning"
      },
      {
        "label": "D",
        "type": "text",
        "value": "All of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Supervised learning algorithms require a dataset that includes both input data and corresponding correct outputs to train the model effectively."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Feature Engineering",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following methods is NOT typically used for dimensionality reduction in feature engineering?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Principal Component Analysis (PCA)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linear Discriminant Analysis (LDA)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "K-Means Clustering"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Autoencoder"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "K-Means Clustering is primarily a clustering method used for grouping similar data points, and it does not inherently reduce dimensionality of the feature space like PCA, LDA, or Autoencoders."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Backpropagation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using the backpropagation technique in training neural networks?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To prevent overfitting"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To optimize the weight initialization"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To adjust the weights of the network"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To increase the learning rate"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The primary purpose of backpropagation is to adjust the weights of the network to minimize the error between the predicted output and the actual output."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Features of Supervised Learning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In supervised learning, what is the role of a labeled dataset during the training phase?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To provide an evaluation metric for model performance"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To serve as a validation set to prevent overfitting"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To guide the algorithm in making accurate predictions"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To enhance the speed of the learning algorithm"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In supervised learning, a labeled dataset is used during the training phase to guide the algorithm in making accurate predictions by providing examples of correct inputs and outputs."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Gini Impurity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What does a Gini impurity of 0 signify in a decision tree node?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The node is perfectly classified."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The node has equal distribution of classes."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The node contains no data points."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The node needs further splitting."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A Gini impurity of 0 indicates that all the samples at a node belong to the same class, which means the node is perfectly classified and no further splitting is necessary."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Splitting Criteria in Decision Trees",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary criterion used by the CART algorithm for selecting the best split at each node in a decision tree for classification?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Chi-square"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Entropy"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Gini impurity"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Information gain"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "CART (Classification and Regression Trees) uses Gini impurity as the default method for choosing the best split in classification trees."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Supervised Learning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In the context of supervised learning, what does the term 'overfitting' refer to?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "A model that performs well on the training data but poorly on unseen data."
      },
      {
        "label": "B",
        "type": "text",
        "value": "A model that is too simple, both underfitting the training and testing datasets."
      },
      {
        "label": "C",
        "type": "text",
        "value": "A model that has not been trained long enough."
      },
      {
        "label": "D",
        "type": "text",
        "value": "A perfectly fitted model with 100% accuracy."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Overfitting occurs when a model learns the detail and noise in the training data to an extent that it negatively impacts the performance of the model on new data. This means the model is too complex, capturing patterns that do not generalize to unseen data."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Random Forest",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a reason for the improved accuracy of Random Forests over individual decision trees?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Reduction of overfitting."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use of ensemble learning."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Higher computational complexity."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Aggregation of predictions from multiple trees."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Higher computational complexity is a drawback, not a reason for improved accuracy. Random Forests improve accuracy through ensemble learning, reduction of overfitting, and aggregating predictions, which average out biases."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Supervised Learning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following algorithms is an example of a supervised learning algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "K-means clustering"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Apriori algorithm"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Linear Regression"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Self-organizing map"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Linear Regression is an example of a supervised learning algorithm where the model is trained with input-output pairs."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Activation Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which activation function would you typically use for the output layer in a neural network designed for a binary classification problem?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ReLU"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sigmoid"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Softmax"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Tanh"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The sigmoid function is ideal for binary classification as it outputs values between 0 and 1, representing probabilities that are interpretable in terms of two classes."
      }
    ]
  },
  {
    "id": 2,
    "topic": "SVM Optimization",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In the context of Support Vector Machines, what is the purpose of the regularization parameter C?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To control the width of the margin"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To determine the kernel type"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To balance the trade-off between achieving a low training error and a low testing error"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To select the optimal hyperplane"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The regularization parameter C is used to balance the trade-off between achieving a low training error and a low testing error, by controlling the penalty for misclassified data points."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Model Evaluation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What metric would you prioritize to evaluate a model used for detecting fraudulent transactions, where false negatives are more costly than false positives?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Accuracy"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Precision"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Recall"
      },
      {
        "label": "D",
        "type": "text",
        "value": "F1 Score"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Recall should be prioritized in scenarios where false negatives (failing to detect fraud) carry higher consequences than false positives, as it measures the ability of a model to detect all relevant cases."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Supervised Learning",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In the context of supervised learning, what is the primary function of a loss function?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To measure the accuracy of the model during training"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To increase the speed of training the model"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To define the architecture of the neural network"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To initialize the weights of the model randomly"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The loss function measures how well the model's predictions match the actual labels during training, guiding the optimization process to minimize errors."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Deep Learning Applications",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In the context of Convolutional Neural Networks (CNN), what is the primary role of pooling layers?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To introduce non-linearity into the model"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To reduce the spatial size of the representation"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To normalize the input features"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To create and train individual neurons"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Pooling layers in CNNs reduce the spatial dimensions (width, height) of the input volume for the next convolutional layer, which decreases the number of parameters and computation in the network, hence also helping to prevent overfitting."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithm Usage",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which learning paradigm is typically used for clustering tasks?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Supervised Learning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Unsupervised Learning"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Semi-supervised Learning"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Reinforcement Learning"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Clustering is a common task in unsupervised learning where the model groups a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Word Embeddings",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which technique for generating word embeddings considers the context of words across the entire corpus to produce embeddings?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "One-hot Encoding"
      },
      {
        "label": "B",
        "type": "text",
        "value": "TF-IDF"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Word2Vec"
      },
      {
        "label": "D",
        "type": "text",
        "value": "GloVe"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "GloVe (Global Vectors for Word Representation) creates word embeddings by aggregating global word-word co-occurrence statistics from a corpus, and then producing a vector space with meaningful substructures."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Word Embeddings",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is a significant advantage of using GloVe embeddings over Word2Vec in terms of training data?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "GloVe requires a smaller dataset"
      },
      {
        "label": "B",
        "type": "text",
        "value": "GloVe can only be trained on structured data"
      },
      {
        "label": "C",
        "type": "text",
        "value": "GloVe utilizes both global and local statistics of a corpus"
      },
      {
        "label": "D",
        "type": "text",
        "value": "GloVe does not rely on neural networks"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "GloVe embeddings are trained on the aggregated global word-word co-occurrence matrix from a corpus, capturing both local and global statistics, unlike Word2Vec which only uses local context information."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Neural Networks",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary function of the activation function in neural networks?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To normalize the input features"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To prevent overfitting"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To introduce non-linearity into the model"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To speed up the training process"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The activation function introduces non-linearity into the model, which allows neural networks to learn complex patterns in the data."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Word Embeddings",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which model is primarily used to generate distributed representation of words?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Word2Vec"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Latent Dirichlet Allocation"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Bag of Words"
      },
      {
        "label": "D",
        "type": "text",
        "value": "TF-IDF"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Word2Vec is specifically designed to create a high-dimensional vector representation of words where similar words have similar encoding."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Overfitting in Decision Trees",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which technique is NOT typically used to prevent overfitting in decision trees?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Pruning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Setting a minimum number of samples per leaf"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using a linear regression model"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Limiting the maximum depth of the tree"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Using a linear regression model is not a method to prevent overfitting in decision trees; it is a different type of predictive modeling technique."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Supervised Learning Algorithms",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which supervised learning algorithm is most suitable for large datasets with a clear linear boundary between classes?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Support Vector Machine (SVM)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "K-Nearest Neighbors (KNN)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Linear Regression"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Logistic Regression"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Logistic Regression is highly efficient for large datasets with a clear linear decision boundary due to its linear decision surface and computational efficiency."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Model Evaluation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What metric is commonly used to evaluate the performance of a model in a regression task?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Accuracy"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Precision"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Recall"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Mean Squared Error"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Mean Squared Error (MSE) is a common metric for evaluating the performance of a regression model by calculating the average of the squares of the errors."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Random Forests",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which feature of random forests reduces the variance of the model compared to a single decision tree?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bootstrap aggregating"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Increased depth of trees"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Use of entropy as a split criterion"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Higher number of trees"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bootstrap aggregating, or bagging, involves training multiple trees on different subsets of the data and averaging their predictions, which reduces the variance of the model."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Hyperplane Margins",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the effect of choosing a very small value for the parameter C in an SVM model?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The margin will be very wide, and the model may underfit."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The margin will be very narrow, and the model may overfit."
      },
      {
        "label": "C",
        "type": "text",
        "value": "There will be no effect on the margin width."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The computation time will decrease significantly."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A smaller C value leads to a larger margin because the SVM model is less penalized for misclassifying training examples. This can lead to a higher bias and lower variance model, potentially causing underfitting."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Loss Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which loss function would you typically use for a binary classification problem?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Mean Squared Error"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Cross-Entropy"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Huber Loss"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Kullback-Leibler Divergence"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Cross-Entropy loss is most suitable for binary classification problems as it measures the performance of a classification model whose output is a probability value between 0 and 1."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Differences in Data Labeling",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which technique requires labeled data for training the model?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Supervised Learning"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Unsupervised Learning"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Both Supervised and Unsupervised Learning"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Neither Supervised nor Unsupervised Learning"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Supervised learning always requires labeled data to train the model because it needs to know the desired output for given inputs."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Feature Importance in Random Forests",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a Random Forest model, what does a higher Mean Decrease Accuracy (MDA) on a feature indicate about its importance?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The feature is less important for making predictions."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The feature is more important for making predictions."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The feature is equally important across all trees in the forest."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The feature's importance cannot be determined from MDA alone."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A higher Mean Decrease Accuracy implies that removing the feature significantly decreases the accuracy of the model, indicating its high importance in making predictions."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Ensemble Learning Techniques",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a Gradient Boosting model, if you increase the learning rate without changing the number of estimators, what is the likely impact on the model's performance on the training dataset?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It will likely overfit the training data, leading to high variance."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It will likely underfit the training data, leading to high bias."
      },
      {
        "label": "C",
        "type": "text",
        "value": "There will be no significant impact on the model's performance."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It will improve the generalization of the model on unseen data."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Increasing the learning rate in Gradient Boosting can cause the model to put too much emphasis on correcting its errors, leading to overfitting on the training data and higher variance."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Pruning in Decision Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true about cost complexity pruning in decision trees?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Cost complexity pruning reduces the size of a decision tree by considering only the leaf nodes."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It uses the accuracy of the tree on the training set to determine the best subtree."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The pruning process is guided by the minimum description length principle."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Pruning continues until further pruning increases the cross-validation error."
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Cost complexity pruning aims to simplify a decision tree by removing subtrees that have the least effect on increasing cross-validation error. It stops when further pruning would increase the error, hence option D is correct."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Activation Functions",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which activation function introduces non-linearity but also has a vanishing gradient problem which affects deep networks during backpropagation?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ReLU"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sigmoid"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Tanh"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Leaky ReLU"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The sigmoid function, while introducing non-linearity, suffers from a vanishing gradient problem where gradients become very small, effectively preventing weights from changing their values, which is particularly problematic for deep networks."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Transformer Models",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which component of Transformer architecture primarily facilitates the handling of long-range dependencies in input sequences?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Positional encodings"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Feed-forward neural networks"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Layer normalization"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Self-attention mechanism"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Option D is correct because the self-attention mechanism allows the model to weigh the influence of different parts of the input sequence, regardless of their positions, which is crucial for understanding dependencies in sequences."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Recurrent Neural Networks",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the primary issue addressed by the introduction of GRU (Gated Recurrent Units) in RNNs?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Vanishing gradient problem"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Exploding gradient problem"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Overfitting"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Underfitting"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "GRUs are designed to combat the vanishing gradient problem in traditional RNNs by using update and reset gates. These gates help to regulate the flow of information and allow the model to retain long-term dependencies, reducing the risk of gradients vanishing through time steps."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Bias-Variance Tradeoff",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a learning algorithm with a low bias and high variance. Which of the following strategies is most likely to reduce variance without significantly increasing bias?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increasing the model complexity"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Adding more training examples"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Reducing the noise in the training data"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Pruning the decision tree more aggressively"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Adding more training examples usually reduces variance by making the model more robust to random fluctuations in the training set, without significantly increasing bias because the underlying model complexity remains unchanged."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Convolutional Neural Networks",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a convolutional neural network, what is the effect of increasing the stride in a convolutional layer?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increases the number of parameters"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Decreases the spatial dimensions of the output"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Increases the spatial dimensions of the output"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Has no effect on the output dimensions"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Increasing the stride in a convolutional layer reduces the spatial dimensions of the output feature map, as the convolutional filter moves in larger steps across the input image."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Neural Network Optimization",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which technique would be most effective for preventing overfitting in a deep neural network model being trained on a small dataset?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increasing the number of layers in the network"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Applying dropout layers at appropriate positions in the network"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using a higher learning rate during training"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Decreasing the batch size"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Applying dropout layers in a neural network is a widely used regularization technique that randomly drops units (along with their connections) during training. This prevents the network from being too dependent on any single or a small group of neurons and helps in reducing overfitting, especially in scenarios involving small datasets."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Support Vector Machines",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In the context of Support Vector Machines (SVM), what is the primary purpose of using the kernel trick?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To linearly separate data that is not linearly separable in the original space by mapping it to a higher dimensional space"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To speed up the training process by reducing the dimensionality of the data"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To prevent overfitting by introducing regularization automatically"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To enhance the feature set by creating additional features manually"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The kernel trick allows SVMs to operate in a high-dimensional space without explicitly computing the coordinates of the data in that space, thus enabling linear separation of data that is not linearly separable in the original space."
      }
    ]
  }
]