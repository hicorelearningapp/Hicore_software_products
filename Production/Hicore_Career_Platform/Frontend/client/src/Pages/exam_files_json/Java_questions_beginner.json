[
  {
    "id": 8,
    "topic": "Event Handling in Swing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which interface must be implemented to handle mouse click events in a Java Swing application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "MouseListener"
      },
      {
        "label": "B",
        "type": "text",
        "value": "KeyListener"
      },
      {
        "label": "C",
        "type": "text",
        "value": "WindowListener"
      },
      {
        "label": "D",
        "type": "text",
        "value": "ActionListener"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The MouseListener interface is used for receiving mouse events like mouse clicks."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Opening and Closing Files",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class is used in Java to open a file for reading?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "FileReader"
      },
      {
        "label": "B",
        "type": "text",
        "value": "FileWriter"
      },
      {
        "label": "C",
        "type": "text",
        "value": "FileOutputStream"
      },
      {
        "label": "D",
        "type": "text",
        "value": "FileInputStream"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "FileReader is used to open a file in Java for reading purposes. It reads text files in the default encoding."
      }
    ]
  },
  {
    "id": 6,
    "topic": "File Writing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class is used to write characters to a file in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "FileOutputStream"
      },
      {
        "label": "B",
        "type": "text",
        "value": "FileWriter"
      },
      {
        "label": "C",
        "type": "text",
        "value": "InputStreamWriter"
      },
      {
        "label": "D",
        "type": "text",
        "value": "BufferedWriter"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "FileWriter is specifically designed for writing characters to a file, making it the correct choice for this purpose."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Inheritance",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which keyword is used for inheriting classes in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "extends"
      },
      {
        "label": "B",
        "type": "text",
        "value": "implements"
      },
      {
        "label": "C",
        "type": "text",
        "value": "inherit"
      },
      {
        "label": "D",
        "type": "text",
        "value": "super"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The 'extends' keyword is used to inherit from a superclass in Java."
      }
    ]
  },
  {
    "id": 9,
    "topic": "JDBC Basics",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method in JDBC is used to execute a SQL query?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "executeQuery()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "executeUpdate()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "execute()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "executeSQL()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The executeQuery() method is used to execute SQL queries that return data, typically SELECT statements."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Java SDK Installation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the first step in setting up a Java development environment?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Download a text editor"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Install the Java Development Kit (JDK)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Create a new Java project"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Configure the system environment variables"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The first step in setting up a Java development environment is to install the Java Development Kit (JDK), which provides the necessary tools to develop Java applications."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Introduction to Swing",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class is used to create a simple window in a Java Swing application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JFrame"
      },
      {
        "label": "B",
        "type": "text",
        "value": "JPanel"
      },
      {
        "label": "C",
        "type": "text",
        "value": "JButton"
      },
      {
        "label": "D",
        "type": "text",
        "value": "JLabel"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JFrame is the base class for creating the main window in a Swing application where components like panels and buttons are added."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Using Java Collections Framework",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class in the Java Collections Framework is used primarily for storing unique elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ArrayList"
      },
      {
        "label": "B",
        "type": "text",
        "value": "HashSet"
      },
      {
        "label": "C",
        "type": "text",
        "value": "HashMap"
      },
      {
        "label": "D",
        "type": "text",
        "value": "LinkedList"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "HashSet is used for storing unique elements as it does not allow duplicates, unlike ArrayList or LinkedList which can contain duplicates."
      }
    ]
  },
  {
    "id": 4,
    "topic": "SQL Injection",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a best practice to prevent SQL injection in Java applications?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using Prepared Statements"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Concatenating SQL commands"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Using simple Statements"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Executing raw user inputs"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Using Prepared Statements is a best practice to prevent SQL injection as it allows the database to distinguish between code and data regardless of user input."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Lambda Expressions",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which is a valid lambda expression in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "(int a, int b) -> { return a + b; }"
      },
      {
        "label": "B",
        "type": "text",
        "value": "(a, b) > a + b"
      },
      {
        "label": "C",
        "type": "text",
        "value": "(a, b) -> a + b"
      },
      {
        "label": "D",
        "type": "text",
        "value": "(a b) -> return a + b;"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The correct lambda expression format in Java is '(parameter list) -> expression'. Option C '(a, b) -> a + b' correctly follows this format."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Types of Exceptions",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a checked exception in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "NullPointerException"
      },
      {
        "label": "B",
        "type": "text",
        "value": "IOException"
      },
      {
        "label": "C",
        "type": "text",
        "value": "ArithmeticException"
      },
      {
        "label": "D",
        "type": "text",
        "value": "ArrayIndexOutOfBoundsException"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "IOException is a checked exception which must be either caught or declared in the method it might be thrown."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Java Installation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which version of Java Development Kit (JDK) introduced the module system?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JDK 7"
      },
      {
        "label": "B",
        "type": "text",
        "value": "JDK 8"
      },
      {
        "label": "C",
        "type": "text",
        "value": "JDK 9"
      },
      {
        "label": "D",
        "type": "text",
        "value": "JDK 10"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "JDK 9 introduced the module system as part of Project Jigsaw, which aimed to make Java more scalable and maintainable."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Basic Syntax",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the correct way to declare a variable to store an integer in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int num = 10;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "integer num = 10;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "num = 10;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Int num = 10;"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, 'int' is the correct keyword to declare an integer. The syntax 'int num = 10;' declares a variable 'num' of type int and initializes it with the value 10."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Basic Components of Java GUI",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class is used to create a basic window in a Java GUI application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JFrame"
      },
      {
        "label": "B",
        "type": "text",
        "value": "JPanel"
      },
      {
        "label": "C",
        "type": "text",
        "value": "JButton"
      },
      {
        "label": "D",
        "type": "text",
        "value": "JLabel"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JFrame is the base class for a window. It provides the basic features needed to create windows, including borders, title, and window controls."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Reading Files",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method is used to read a single character from a file in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "read()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "readLine()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "readChar()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "getFile()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The read() method of FileReader class in Java is used to read a single character from the file."
      }
    ]
  },
  {
    "id": 10,
    "topic": "JSP Fundamentals",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What tag in JSP is used to write Java code inside the HTML?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "<%! %>"
      },
      {
        "label": "B",
        "type": "text",
        "value": "<%= %>"
      },
      {
        "label": "C",
        "type": "text",
        "value": "<%@ %>"
      },
      {
        "label": "D",
        "type": "text",
        "value": "<% %>"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The <% %> tag is used to embed Java code in JSP, which will be executed to dynamically generate HTML content."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Data Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following data types would be best for storing a simple 'yes' or 'no' answer in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int"
      },
      {
        "label": "B",
        "type": "text",
        "value": "boolean"
      },
      {
        "label": "C",
        "type": "text",
        "value": "double"
      },
      {
        "label": "D",
        "type": "text",
        "value": "String"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The boolean data type in Java represents one bit of information which can be either true or false, perfect for a 'yes' or 'no' answer."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Event Handling in Java GUI",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which interface must a class implement to handle action events in Java GUI applications?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "ActionListener"
      },
      {
        "label": "B",
        "type": "text",
        "value": "MouseListener"
      },
      {
        "label": "C",
        "type": "text",
        "value": "KeyListener"
      },
      {
        "label": "D",
        "type": "text",
        "value": "WindowListener"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "ActionListener is used to receive action events like button clicks. Classes that need to handle these events should implement this interface."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Syntax",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the correct way to declare a variable to store an integer in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int num = 100;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "integer num = 100;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "num = 100;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Int num = 100;"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, 'int' is the correct keyword for declaring integer variables. The syntax includes the keyword followed by a variable name and, optionally, an initialization."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Basic Components",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class is used to create a simple frame in a Java GUI application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "JFrame"
      },
      {
        "label": "B",
        "type": "text",
        "value": "JPanel"
      },
      {
        "label": "C",
        "type": "text",
        "value": "JButton"
      },
      {
        "label": "D",
        "type": "text",
        "value": "JLabel"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "JFrame is the class used for creating a window in Java Swing applications where components like panels and buttons can be added."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Exception Handling",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which exception is thrown when trying to access an index that is out of bounds for an array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "NullPointerException"
      },
      {
        "label": "B",
        "type": "text",
        "value": "ArrayIndexOutOfBoundsException"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Exception"
      },
      {
        "label": "D",
        "type": "text",
        "value": "IndexOutOfBoundsException"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "ArrayIndexOutOfBoundsException is specifically thrown when an array has been accessed with an illegal index."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Data Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which data type would you use to store a simple true or false value in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "boolean"
      },
      {
        "label": "B",
        "type": "text",
        "value": "double"
      },
      {
        "label": "C",
        "type": "text",
        "value": "int"
      },
      {
        "label": "D",
        "type": "text",
        "value": "string"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, the 'boolean' data type is used to store a value that can only be either true or false."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Data Transmission",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which class in Java is used for sending and receiving datagram packets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "DatagramSocket"
      },
      {
        "label": "B",
        "type": "text",
        "value": "PacketSocket"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Socket"
      },
      {
        "label": "D",
        "type": "text",
        "value": "DataSocket"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The DatagramSocket class is specifically designed for sending and receiving packets of data using the datagram protocol."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Interface Implementation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is true about interfaces in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "An interface can contain instance fields."
      },
      {
        "label": "B",
        "type": "text",
        "value": "An interface cannot contain any method implementations."
      },
      {
        "label": "C",
        "type": "text",
        "value": "An interface can be instantiated directly."
      },
      {
        "label": "D",
        "type": "text",
        "value": "An interface can only contain static methods."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, an interface cannot contain any method implementations; it can only contain method declarations."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Basic Syntax",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is the correct way to declare a variable in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "int num = 10;"
      },
      {
        "label": "B",
        "type": "text",
        "value": "int 10 = num;"
      },
      {
        "label": "C",
        "type": "text",
        "value": "num = 10 int;"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10 = int num;"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, variables are declared by first specifying the type, followed by the variable name and optionally initializing it. Option A follows this rule."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Switch Statements",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What will the following Java code snippet output if the variable 'day' is 3? \n\nswitch (day) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  case 2:\n    System.out.println(\"Tuesday\");\n    break;\n  case 3:\n    System.out.println(\"Wednesday\");\n    break;\n  default:\n    System.out.println(\"Another day\");\n}"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Monday"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Tuesday"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Wednesday"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Another day"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'day' variable is 3, which matches case 3, so 'Wednesday' is printed."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Java Assertions",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using assertions in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To provide runtime feedback about the internal state of a program"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To handle exceptions"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To improve the performance of the program"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To terminate the program explicitly"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Assertions are used to provide runtime feedback about the internal state of a program, helping developers identify and fix bugs more efficiently."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Thread Synchronization",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the purpose of the 'synchronized' keyword in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To pause the execution of the current thread"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To start a new thread"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To ensure that only one thread can access a resource at a time"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To terminate a thread"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'synchronized' keyword is used to control the access of multiple threads to any shared resource. It ensures that only one thread can access the resource at a time, preventing race conditions."
      }
    ]
  },
  {
    "id": 1,
    "topic": "JDBC Basics",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method is used to establish a connection to the database in JDBC?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "DriverManager.getConnection()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Driver.connect()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Connection.createStatement()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "DriverManager.createConnection()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "DriverManager.getConnection() is the correct method to establish a connection to the database using JDBC."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Thread Creation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which method is used to start a thread in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "start()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "run()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "call()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "execute()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The start() method of the Thread class is used to begin the execution of a new thread. The run() method is called after start() is invoked."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Polymorphism",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true regarding method overriding in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Overridden methods must have a different return type than the method in the parent class."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Overridden methods must have the same return type as the method in the parent class."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Overridden methods can only be implemented in subclasses."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Overridden methods must have a different method signature than the method in the parent class."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, an overridden method must have the same return type, name, and parameter list (method signature) as the method in the parent class."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Servlets in Java",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is true about the lifecycle methods of a servlet?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "init() is called only once, while service() and destroy() can be called multiple times."
      },
      {
        "label": "B",
        "type": "text",
        "value": "init() and destroy() are called multiple times for each request."
      },
      {
        "label": "C",
        "type": "text",
        "value": "service() method is called only once during the lifecycle of a servlet."
      },
      {
        "label": "D",
        "type": "text",
        "value": "destroy() method is called after every response."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The init() method is called once to initialize the servlet, service() handles all requests and can be called multiple times, and destroy() is called once when the servlet is taken out of service."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Inheritance",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will be the output of the following Java code if the method display() is called on an object of subclass?"
      },
      {
        "type": "text",
        "value": "class SuperClass { int num = 20; public void display() { System.out.println(this.num); } } class SubClass extends SuperClass { int num = 10; }"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "20"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10"
      },
      {
        "label": "C",
        "type": "text",
        "value": "0"
      },
      {
        "label": "D",
        "type": "text",
        "value": "None of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In Java, when a method is called on a subclass object that inherits from a superclass, the properties of the superclass are used unless they are overridden in the subclass. In this case, the display() method in SuperClass uses its own num property, not the num property of SubClass."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Exception Handling",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of these is not a checked exception in Java?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "IOException"
      },
      {
        "label": "B",
        "type": "text",
        "value": "SQLException"
      },
      {
        "label": "C",
        "type": "text",
        "value": "NumberFormatException"
      },
      {
        "label": "D",
        "type": "text",
        "value": "ClassNotFoundException"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "NumberFormatException is a RuntimeException, which is an unchecked exception, not requiring mandatory handling in the program."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Loop Control",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the output of the following loop in Java if the initial value of 'i' is 0?"
      },
      {
        "type": "formula",
        "value": "for (int i = 0; i < 5; i++) { System.out.print(i + \\\" \\\"); }"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "0 1 2 3 4 "
      },
      {
        "label": "B",
        "type": "text",
        "value": "1 2 3 4 5 "
      },
      {
        "label": "C",
        "type": "text",
        "value": "0 1 2 3 4 5 "
      },
      {
        "label": "D",
        "type": "text",
        "value": "None of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The loop starts at 0 and increments by 1 each iteration until it is less than 5, hence it prints 0 to 4."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Map Interface",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will happen if a null value is used as a key in a HashMap?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "HashMap will store the null key successfully."
      },
      {
        "label": "B",
        "type": "text",
        "value": "HashMap throws a NullPointerException."
      },
      {
        "label": "C",
        "type": "text",
        "value": "HashMap ignores the null key."
      },
      {
        "label": "D",
        "type": "text",
        "value": "HashMap replaces the null key with a default value."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "HashMap allows one null key and multiple null values, so it will successfully store the null key without any issues."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Finally Block",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which statement is true about the 'finally' block in Java exception handling?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The 'finally' block executes only if an exception is thrown in the try block."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The 'finally' block executes regardless of whether an exception is thrown or not."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The 'finally' block is optional and can be omitted if there is at least one catch block."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The 'finally' block does not execute if the program exits (via System.exit()) before reaching it."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The 'finally' block in Java is designed to execute after the try and any corresponding catch blocks, regardless of whether an exception was thrown or caught. The only exception to this rule is if the JVM exits (via System.exit() or a fatal error) before the finally block can execute."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Hierarchy of Exceptions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the output of the following code snippet if the number array is {3, 0, 5}?"
      },
      {
        "type": "formula",
        "value": "try { \\text{int result = 10 / number[i];} \\text{System.out.println(result);} } catch(Exception e) { \\text{System.out.println(\"Generic Exception\");} } catch(ArithmeticException e) { \\text{System.out.println(\"Arithmetic Exception\");} }"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "10\\nGeneric Exception\\n2"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10\\nArithmetic Exception\\n2"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Arithmetic Exception only"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Generic Exception only"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Option D is correct because the catch block for ArithmeticException is never reached. The generic Exception block catches all exceptions, including ArithmeticException."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Encapsulation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Why is encapsulation considered a good practice in object-oriented programming?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It allows the class implementation to be changed without affecting other parts of the program."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It forces all subclasses to inherit all methods and properties."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It allows methods to be overridden more easily."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It requires all fields to be public."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Encapsulation protects an object's state by hiding its attributes and exposing only selected methods. This allows the class to change its internal implementation without negatively affecting other classes that depend on it."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Polymorphism",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What concept in Java allows the use of the same interface for different underlying forms (data types)?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Encapsulation"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Abstraction"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Polymorphism"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Inheritance"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Polymorphism in Java allows the programmer to use the same interface for different underlying forms of data types."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Servlet Lifecycle",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements correctly describes the behavior of the container in the 'service' phase of a servlet's lifecycle?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The container calls the service method only once when the servlet is first created."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The container does not call the service method; instead, it directly invokes doGet or doPost methods based on the request type."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The container calls the service method each time the servlet is accessed by a request, delegating to doGet, doPost, or other methods as necessary."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The container manages concurrent requests by creating a new instance of the servlet for each new request."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The correct answer is C because the service method is designed to handle all requests to the servlet, dispatching them to the appropriate request handling methods like doGet or doPost depending on the HTTP request type."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Servlet Lifecycle",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a phase in the lifecycle of a servlet?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Initialization"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Execution"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Destruction"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Compilation"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Servlets are not compiled as a phase in their lifecycle. Their phases include initialization, execution, and destruction."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Java Application Scalability",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which Java Virtual Machine (JVM) parameter is crucial for optimizing performance in a high-load, multi-threaded application environment?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "-Xms and -Xmx to set the initial and maximum heap size"
      },
      {
        "label": "B",
        "type": "text",
        "value": "-XX:MaxPermSize to set the size of the permanent generation space"
      },
      {
        "label": "C",
        "type": "text",
        "value": "-XX:+UseConcMarkSweepGC to enable the concurrent mark-sweep collector"
      },
      {
        "label": "D",
        "type": "text",
        "value": "-XX:+UseSerialGC to use the serial garbage collector"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "For high-load, multi-threaded environments, enabling -XX:+UseConcMarkSweepGC helps in managing the application's memory more efficiently by using concurrent mark-sweep collection, thereby improving performance."
      }
    ]
  },
  {
    "id": 1,
    "topic": "JDBC Transaction Management",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a JDBC transaction, if a Savepoint named 'Savepoint1' is set after updating three rows and another 'Savepoint2' is set after updating five more rows, how many rows will be affected if a rollback is issued to 'Savepoint1'?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "3 rows"
      },
      {
        "label": "B",
        "type": "text",
        "value": "5 rows"
      },
      {
        "label": "C",
        "type": "text",
        "value": "8 rows"
      },
      {
        "label": "D",
        "type": "text",
        "value": "None"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Rolling back to 'Savepoint1' undoes all changes made after this point. Therefore, the updates made to the five additional rows after setting 'Savepoint1' will be undone, affecting 5 rows."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Java Memory Model",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In the context of Java Memory Model, which statement is true about the 'happens-before' consistency?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Actions in a single thread always happen-before each other."
      },
      {
        "label": "B",
        "type": "text",
        "value": "A thread can access its own local variables without synchronization."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The unlock on a monitor lock happens-before every subsequent lock on the same monitor."
      },
      {
        "label": "D",
        "type": "text",
        "value": "None of the above statements are true."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The unlock on a monitor lock happens-before every subsequent lock on the same monitor, ensuring changes to the state of the monitor are visible to all threads."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Concurrency in Java",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When using a ConcurrentHashMap in a multi-threaded environment, what is the impact of the initial capacity on performance?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Higher initial capacity reduces the need for resizing, improving performance."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Initial capacity has no impact on performance."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Lower initial capacity enhances CPU cache utilization, thus improving performance."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Higher initial capacity increases memory overhead, degrading performance."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In a ConcurrentHashMap, a higher initial capacity helps avoid frequent resizing of the map as more elements are added, which is costly in terms of performance. Hence, setting a higher initial capacity at the start can lead to better performance by reducing the need for resizing."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Socket Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When implementing a multi-threaded server handling multiple client connections simultaneously, which Java class is ideally used to manage client-specific tasks within a new thread?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "java.net.ServerSocket"
      },
      {
        "label": "B",
        "type": "text",
        "value": "java.net.Socket"
      },
      {
        "label": "C",
        "type": "text",
        "value": "java.lang.Thread"
      },
      {
        "label": "D",
        "type": "text",
        "value": "java.util.concurrent.ExecutorService"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The java.util.concurrent.ExecutorService is ideal for managing multiple threads efficiently, allowing the server to handle each client connection in a separate thread without the need to manually manage thread lifecycle."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Type Conversion and Casting",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given the following Java code snippet, what is the output?\n\nint a = 130;\nbyte b = (byte)a;\nSystem.out.println(b);"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "-126"
      },
      {
        "label": "B",
        "type": "text",
        "value": "130"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Error"
      },
      {
        "label": "D",
        "type": "text",
        "value": "30"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bytes in Java are signed and have a range from -128 to 127. When 130 (which exceeds the byte range) is cast to a byte, Java uses modulo 256 arithmetic resulting in the output -126."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Event Handling in JavaFX",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In JavaFX, which class is NOT directly involved in the process of handling mouse events?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "MouseEvent"
      },
      {
        "label": "B",
        "type": "text",
        "value": "MouseAdapter"
      },
      {
        "label": "C",
        "type": "text",
        "value": "EventHandler"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Event"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "MouseAdapter is part of AWT and is not directly used in JavaFX, which uses EventHandler for handling mouse events."
      }
    ]
  },
  {
    "id": 2,
    "topic": "FileChannel Techniques",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In Java's NIO package, which method correctly transfers data from a source FileChannel to a destination FileChannel, ensuring the position of the source channel remains unaltered?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "destinationChannel.transferFrom(sourceChannel, 0, sourceChannel.size());"
      },
      {
        "label": "C",
        "type": "text",
        "value": "sourceChannel.position(0); destinationChannel.write(sourceChannel.map(FileChannel.MapMode.READ_ONLY, 0, sourceChannel.size()));"
      },
      {
        "label": "D",
        "type": "text",
        "value": "ByteBuffer buffer = ByteBuffer.allocateDirect((int)sourceChannel.size()); sourceChannel.read(buffer); buffer.flip(); destinationChannel.write(buffer); sourceChannel.position(0);"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Option D is correct because it manually reads data into a ByteBuffer, writes it to the destination channel, and then explicitly resets the source channel's position to zero. This ensures the source channel\u2019s position remains unchanged after the operation, which is not guaranteed by the transferTo and transferFrom methods."
      }
    ]
  }
]