[
  {
    "id": 4,
    "topic": "Searching Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of data structure is required for binary search to be applicable?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Unsorted Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sorted Array"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search requires a sorted array to function properly, as it repeatedly divides the search interval in half."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Big O notation describe in terms of algorithm complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Upper bound on the running time or memory usage"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Exact running time or memory usage"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Lower bound on the running time or memory usage"
      },
      {
        "label": "D",
        "type": "text",
        "value": "None of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O notation provides an upper limit on the running time or memory usage concerning the input size, describing the worst-case scenario."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Algorithm Efficiency",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following algorithms is generally fastest on large data sets for sorting?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Selection Sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is generally faster than Bubble Sort, Insertion Sort, and Selection Sort for large data sets due to its divide and conquer approach."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Basic Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does an algorithm typically aim to achieve?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To create a visual representation of data"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To solve a problem using a step-by-step procedure"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase the complexity of a program"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the efficiency of data processing"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "An algorithm is a set of steps designed to solve a problem or perform a specific task."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which control structure would be most appropriate for executing a block of code multiple times based on a condition?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "While Loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "If Statement"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Switch Case"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Try-Catch Block"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A while loop executes a block of code repeatedly as long as the given condition is true, making it suitable for this scenario."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Big O Notation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Big O Notation describe in algorithm analysis?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The worst-case scenario of the algorithm's running time or space requirement."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The best-case scenario of the algorithm's performance."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The algorithm's performance on average data input."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The hardware requirements for running the algorithm."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O Notation provides an upper limit on the running time or memory usage concerning the input size, describing the worst-case scenario."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Tree Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tree data structure is generally used for faster search, insert, and delete operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "B",
        "type": "text",
        "value": "AVL Tree"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Red-Black Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Search Tree"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. This self-balancing property leads to faster search, insert, and delete operations."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Array Operations",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by index is a direct operation, which takes constant time, hence the time complexity is O(1)."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is not a comparison-based sorting algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Counting sort"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Counting sort is a non-comparison-based sorting algorithm that sorts elements by counting the number of occurrences of each unique value."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is generally considered the fastest for large datasets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Selection Sort"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is generally considered the fastest for large datasets due to its divide and conquer approach, which averages O(n log n) time complexity."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Hash Tables",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a primary advantage of using a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Fixed size"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Data sorted order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Low memory usage"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Fast data retrieval"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The primary advantage of using a hash table is fast data retrieval, generally achieving average-case constant-time complexity, O(1), for lookups."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Algorithm Complexity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of a binary search algorithm on a sorted array of n elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(1)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search repeatedly divides the array into halves, leading to a time complexity of O(log n)."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Hash Function",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of a hash function in a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To store values"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To sort keys"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To generate a unique index for each key"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To encrypt data"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The hash function's primary purpose in a hash table is to compute an index into an array in which an element will be inserted or searched. By using a hash function, hash tables can achieve very efficient average time complexity for insertions, deletions, and searches."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithm Optimization",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a characteristic of dynamic programming algorithms?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Does not store the results of subproblems"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Uses a divide and conquer approach without overlapping subproblems"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Solves each subproblem just once and stores its result"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Exponential time complexity is typical"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Dynamic programming algorithms solve each subproblem only once and store the result in a table to avoid the work of recomputing the answer every time the subproblem is encountered."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Control Structures in Programming",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which control structure would be most appropriate for processing each element in a list of known size?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "For Loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "If-Else Statements"
      },
      {
        "label": "C",
        "type": "text",
        "value": "While Loop"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Switch Case"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A For Loop is ideal for iterating over a list of known size as you can specify the number of iterations based on the size of the list."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Binary Search",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of a binary search algorithm on a sorted array of size n?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n^2)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search repeatedly divides the array into halves, leading to a logarithmic time complexity of O(log n)."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Hash Functions",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following scenarios is best suited for the use of a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Finding the shortest path between two nodes in a graph."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Managing user sessions where each session is uniquely identified by a session ID."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Balancing a binary search tree."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Calculating factorial of a number."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Hash tables are ideal for scenarios where quick lookup, insertion, and deletion operations based on unique keys are required, such as managing unique session IDs."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Graph Data Structures",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true regarding undirected graphs?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Each edge creates a one-way connection between two vertices."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The adjacency matrix is always asymmetric."
      },
      {
        "label": "C",
        "type": "text",
        "value": "An undirected edge is represented twice in an adjacency list."
      },
      {
        "label": "D",
        "type": "text",
        "value": "They are primarily used to represent hierarchical data."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In an undirected graph, an edge between two vertices is bidirectional and is represented twice in an adjacency list, once for each vertex."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Time Complexity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding the greatest common divisor (GCD) using Euclid's algorithm for two numbers a and b?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(log(min(a, b)))"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(a + b)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log(a*b))"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(a*b)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Euclid's algorithm repeatedly subtracts the smaller number from the larger one. This process effectively reduces the problem size logarithmically, leading to a time complexity of O(log(min(a, b)))."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Time Complexity",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of finding the median in an unsorted array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n^2)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The median can be found in O(n) time using the QuickSelect algorithm, which is a selection algorithm based on the partitioning of the QuickSort."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Data Structures",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following data structures can be used to efficiently implement Dijkstra's algorithm with a better complexity than O(V^2)?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linked List"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Heap"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Stack"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Using a binary heap, Dijkstra's algorithm can achieve a time complexity of O((V+E) log V) which is more efficient than O(V^2) when implemented with an array."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Binary Search Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a binary search tree (BST) which initially contains values 10, 20, 30, 40, 50. Which of the following sequences of values can be an in-order traversal after inserting a single new value into the BST?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "10, 15, 20, 30, 40, 50"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10, 20, 35, 30, 40, 50"
      },
      {
        "label": "C",
        "type": "text",
        "value": "10, 20, 30, 35, 40, 50"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10, 20, 30, 40, 50, 60"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In-order traversal of a BST provides elements in a non-decreasing order. Option C is the only sequence that maintains this order after inserting a new value (35)."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Time Complexity",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider two algorithms. Algorithm A has a time complexity of O(n log n) and Algorithm B has a time complexity of O(n^2). For large values of n, which algorithm is more efficient and why?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Algorithm A, because logarithmic growth is slower than polynomial growth."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Algorithm B, because polynomial growth is slower than logarithmic growth."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Both are equally efficient as their time complexities are polynomial."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Cannot determine without knowing more about the specific tasks the algorithms perform."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Algorithm A is more efficient for large values of n because O(n log n) grows slower compared to O(n^2). This means Algorithm A will generally have fewer steps as n becomes large."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Graph Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a directed graph, what is the time complexity of detecting a cycle using Depth-First Search (DFS)?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(V)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(V + E)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(V^2)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(E^2)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The time complexity of cycle detection using DFS in a directed graph is O(V + E) where V is the number of vertices and E is the number of edges. This accounts for visiting each vertex and exploring each edge."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Data Structures and Algorithm Complexity",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given an array of integers where each element represents the maximum number of steps that can be jumped going forward from that element, write the function 'minJumps(start, end)' to determine the minimum number of jumps you must take to go from the start position to the end position."
      },
      {
        "type": "formula",
        "value": "function minJumps(start, end) { // function definition }"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use a greedy approach to take the furthest reachable step at each move."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Implement a depth-first search to explore all possible paths and choose the shortest."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Apply dynamic programming to find the minimum jumps from start to end by building a jumps table."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Sort the array and linearly iterate to find the minimum jumps."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Dynamic programming is the most efficient way to solve this problem. By building a jumps table that records the minimum jumps needed to reach each index from the start, one can efficiently determine the minimum jumps needed to reach the end."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Advanced Binary Search",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider an infinite sorted array where numbers are not consecutive but are in increasing order. You are given a target number to search. Which of the following methods optimizes the time complexity for finding the target?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using a simple binary search from the start without modifications."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Expanding the search range exponentially, then performing a binary search within the range."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Performing a linear search from the start of the array."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Sorting the array again in descending order and using binary search."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Option B is correct because initially expanding the range exponentially (like 2^0, 2^1, ... until the upper bound is greater than the target) and then performing binary search within that known range optimizes the time complexity for an infinite sorted array scenario."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Binary Search Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a binary search tree, if you perform an in-order traversal, which of the following sequences could represent the output for a correctly structured binary search tree?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "1, 3, 4, 6, 8, 10, 11"
      },
      {
        "label": "B",
        "type": "text",
        "value": "10, 6, 4, 3, 8, 11, 1"
      },
      {
        "label": "C",
        "type": "text",
        "value": "11, 10, 8, 6, 4, 3, 1"
      },
      {
        "label": "D",
        "type": "text",
        "value": "1, 3, 4, 6, 11, 8, 10"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A presents a sequence that could result from an in-order traversal of a binary search tree (smallest to largest), which adheres to the left-root-right rule inherent to in-order traversals. The other sequences do not reflect the necessary ascending order."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Binary Search Variants",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider an infinite sorted array where elements follow a pattern, with every nth element being the square of an integer (e.g., [1, 4, 9, 16, ...]). Using a modified binary search, which is the minimum number of steps required to find the position of the number 256?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "8 steps"
      },
      {
        "label": "B",
        "type": "text",
        "value": "16 steps"
      },
      {
        "label": "C",
        "type": "text",
        "value": "12 steps"
      },
      {
        "label": "D",
        "type": "text",
        "value": "10 steps"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Since the array follows the squares of integers, the position of 256 (which is 16^2) can be calculated by finding the square root of 256, giving 16. Using binary search, it takes log2(16) which is 4, then doubling the window size logarithmically requires an additional 4 steps."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Sorting Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Which of the following sorting algorithms has the best worst-case runtime complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Insertion Sort"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Merge Sort has a worst-case time complexity of O(n log n), which is more efficient compared to Quick Sort's O(n^2) and both Bubble Sort's and Insertion Sort's O(n^2) in their worst-case scenarios."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Binary Search Variations",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a sorted array that has been rotated at an unknown pivot, which of the following modifications to the traditional binary search algorithm is necessary to efficiently find an element?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Modify the algorithm to first find the pivot where the array is rotated."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Adjust the binary search to start from the midpoint regardless of the pivot."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Implement a linear search instead of binary search."
      },
      {
        "label": "D",
        "type": "text",
        "value": "No modification is necessary; traditional binary search will still work."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "To find an element in a rotated sorted array, you must first identify the pivot point where the order breaks. After finding the pivot, you can apply binary search on one of the two subarrays which are normally sorted."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Time Complexity",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given an algorithm with a loop that doubles the value of 'n' each iteration starting from 1 until it surpasses 'N', what is the time complexity of this algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(N)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log N)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(N log N)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(2^N)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Each loop iteration doubles the value of 'n', thus it takes approximately log_2(N) iterations for 'n' to exceed 'N'. Hence, the time complexity is O(log N)."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Recursive Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a recursive algorithm designed to find the factorial of a number. What is a potential drawback of using recursion for this problem in real-world applications?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Increased memory usage due to stack overflow"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Decreased accuracy of the result"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Longer execution time compared to iterative solutions"
      },
      {
        "label": "D",
        "type": "text",
        "value": "All of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Recursive algorithms, especially for calculating factorial, can lead to increased memory usage due to the large number of stack frames created for each function call. This can lead to stack overflow if the recursion is too deep. Accuracy is not typically affected, and execution time can be similar to iterative solutions, although it can vary."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Graph Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a directed graph where every vertex is connected to every other vertex via a unique directed edge. If there are 5 vertices in the graph, how many unique shortest paths exist from vertex A to vertex E assuming there are no weights on the edges?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "24"
      },
      {
        "label": "B",
        "type": "text",
        "value": "120"
      },
      {
        "label": "C",
        "type": "text",
        "value": "1"
      },
      {
        "label": "D",
        "type": "text",
        "value": "4"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In a fully connected directed graph, there is exactly one direct edge from any vertex A to vertex E, making the unique shortest path count 1."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Complexity of Sorting Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "When comparing Quick Sort and Merge Sort in a worst-case scenario, what is the time complexity of each, and which algorithm generally performs better in terms of stability?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Quick Sort: O(n^2), Merge Sort: O(n log n), Merge Sort is more stable"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort: O(n log n), Merge Sort: O(n^2), Quick Sort is more stable"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort: O(n log n), Merge Sort: O(n log n), Both are equally stable"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Quick Sort: O(n^2), Merge Sort: O(n), Quick Sort is more stable"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In the worst-case scenario, Quick Sort has a time complexity of O(n^2) when the pivot elements are not well chosen (e.g., always the smallest or largest element), whereas Merge Sort consistently maintains a time complexity of O(n log n). Merge Sort is also more stable as it does not change the relative order of equal elements."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Efficiency of Sorting Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given an array consisting of n elements that are initially sorted but then rotated k positions, what is the most efficient way to find the minimum element?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Use linear search to find the minimum."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Use binary search to find the minimum."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Sort the array again and select the first element."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Use quicksort and select the first element after sorting."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search can be modified to efficiently find the minimum element in a rotated sorted array with a complexity of O(log n), which is more efficient than linear search O(n) or re-sorting the array O(n log n)."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithm Optimization",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Considering a function that calculates the nth Fibonacci number using a naive recursive approach, what is the time complexity?"
      },
      {
        "type": "formula",
        "value": "T(n) = T(n-1) + T(n-2) + O(1)"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(2^n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The naive recursive approach for Fibonacci sequence computation has a time complexity of O(2^n) due to the exponential growth of recursive calls, as each call generates two additional calls except for the base cases."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Array Operations",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of inserting an element at the beginning of an array with 'n' elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Inserting an element at the beginning of an array requires shifting all existing elements one position to the right, resulting in a time complexity of O(n)."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Graph Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a directed graph, which of the following statements is TRUE regarding a depth-first search (DFS) traversal starting from a node u?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "DFS traversal will visit all nodes reachable from u in increasing order of their distances from u."
      },
      {
        "label": "B",
        "type": "text",
        "value": "DFS traversal guarantees to find the shortest path from u to any other node in the graph."
      },
      {
        "label": "C",
        "type": "text",
        "value": "DFS traversal may not visit all nodes in the graph if there are cycles."
      },
      {
        "label": "D",
        "type": "text",
        "value": "DFS traversal can be used to detect cycles and topologically sort the graph."
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "DFS traversal can indeed be used to detect cycles in directed graphs by checking for back edges during the traversal. Additionally, DFS can be utilized for topological sorting by ordering vertices according to their finishing times."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Arrays",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In an unsorted array of n integers, which of the following operations is most efficient in terms of time complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Finding the maximum element"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Deleting a specific element given its index"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Inserting an element at a specific index"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Searching for a specific element"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Finding the maximum element in an unsorted array can be achieved in O(n) by iterating through the array once, which is more efficient than deleting or inserting at a specific index (O(n) but requires additional operations), or searching for a specific element (O(n) but with potentially higher constant factors depending on the data)."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Graph Traversal Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a directed acyclic graph (DAG), if we perform a topological sort and then reverse the order of the resulting list, what specific ordering of the nodes do we achieve?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Reverse topological order"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Lexicographical order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Depth-first search completion order"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Breadth-first search order"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Reversing the topological sort of a DAG results in the reverse topological order. This order is the exact opposite of the dependencies direction in the DAG."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Tree Traversal",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a binary search tree, which traversal method would you use to print the elements of the tree in descending order?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "In-order Traversal"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Pre-order Traversal"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Post-order Traversal"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Reverse In-order Traversal"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "In-order traversal of a binary search tree prints the elements in ascending order. To print in descending order, a reverse in-order traversal (right-left-root) is used."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Dynamic Programming",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a sequence, a1, a2, ..., an, the function f(i, j) represents the sum of ai, ..., aj inclusive. If f(i, j) is exactly divisible by n, count the number of possible (i, j) pairs. The sequence is [2, 4, 1, 3, 5]. What is the count of such pairs?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "2"
      },
      {
        "label": "B",
        "type": "text",
        "value": "3"
      },
      {
        "label": "C",
        "type": "text",
        "value": "4"
      },
      {
        "label": "D",
        "type": "text",
        "value": "5"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Calculate the sum for each possible (i, j) pair and check its divisibility by n. Pairs (3, 4) and (1, 5) match the criteria."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Graph Traversal",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a directed acyclic graph (DAG), which of the following statements is true regarding a Depth First Search (DFS) traversal?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "DFS will always visit all nodes in the graph if started from any node"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The finish time of a node will always be greater than all nodes reachable from it"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The start time of a node will always be less than all nodes reachable from it"
      },
      {
        "label": "D",
        "type": "text",
        "value": "DFS cannot be used to find the shortest path in a DAG"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In a DFS of a DAG, once a node is finished, all nodes reachable from that node have already been explored and finished, hence their finish time is less."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Binary Search Trees",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Given a Binary Search Tree (BST) where each node contains integer values, which of the following operations will result in an unbalanced BST if performed repeatedly?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Inserting an element greater than all existing elements"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Inserting an element less than all existing elements"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Inserting random elements"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Inserting elements in ascending order"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Inserting an element greater than all existing elements repeatedly causes right-skewed growth, which unbalances the BST as it takes the form of a linked list, increasing search operation complexity to O(n)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Hash Tables",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In the context of hash tables, what is the worst-case time complexity of searching for an element in a poorly implemented hash table using chaining as a collision resolution technique?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In the worst case, all items could end up in the same bucket, leading to a time complexity of O(n) for search operations, where n is the number of elements in the hash table."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Time Complexity of Sorting Algorithms",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Considering average-case scenarios, which of the following sorting algorithms does not have a time complexity of O(n log n)?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Heap Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Bubble Sort"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort typically has an average-case time complexity of O(n^2), making it less efficient compared to Merge Sort, Quick Sort, and Heap Sort which all have average-case complexities of O(n log n)."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Algorithmic Problem Solving in Real-world Applications",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "Consider a large dataset of student records that need to be sorted based on multiple fields (name, grade, and date of birth). Which sorting algorithm would be best suited for this scenario, assuming that comparison operations are costly?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Merge Sort is ideal for scenarios where comparison is expensive because it minimizes the number of comparisons in the worst case. For large datasets like this, its stability and efficiency in handling large data make it the optimal choice."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Recursion and Backtracking",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "In a recursive function designed to find the maximum path sum from top to bottom in a binary tree, what is the time complexity if every node has at most two children and the height of the tree is h?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(h)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log h)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(h^2)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(2^h)"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "The recursive function is called for each node in the binary tree, leading to a time complexity of O(2^h), where h is the height of the tree."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Algorithm Optimization",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "What is the best time complexity that can be achieved through any comparison-based sorting algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(N)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(N log N)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log N)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(N^2)"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The lower bound for any comparison-based sorting algorithm is O(N log N), as proven by the decision tree model of computations, which shows that at least log_2(N!) comparisons are necessary."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Recursion and Iteration Techniques",
    "difficulty": "hard",
    "question": [
      {
        "type": "text",
        "value": "A recursive algorithm and an iterative algorithm are implemented to solve the same problem. If the time complexity of the recursive algorithm is represented by T(n) = 2T(n/2) + n and the iterative version has a time complexity of O(n log n), which scenario would lead to a better performance of the recursive algorithm over the iterative one with respect to space complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "When the depth of the recursion tree is less than log n"
      },
      {
        "label": "B",
        "type": "text",
        "value": "When the depth of the recursion tree is greater than log n"
      },
      {
        "label": "C",
        "type": "text",
        "value": "When auxiliary space used by recursion is optimized using tail recursion"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The iterative algorithm always has better space complexity"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Option C is correct because tail recursion, an optimized form of recursion, helps in reducing the space complexity by reusing stack frames and hence can be more space-efficient than an iterative approach which uses separate space for each loop iteration."
      }
    ]
  }
]