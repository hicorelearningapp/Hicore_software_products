[
  {
    "id": 3,
    "topic": "Basic Concepts",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which data structure is best suited for implementing a queue?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Linked List"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Array"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Tree"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A Linked List is best suited for a queue because it allows for efficient insertion and deletion from both ends."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which control structure would be most appropriate for executing a block of code multiple times based on a condition?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "If-else statement"
      },
      {
        "label": "B",
        "type": "text",
        "value": "While loop"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Switch-case statement"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Exit loop"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A while loop is used for repeated execution as long as an expression is true, making it suitable for the described use case."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Introduction to Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is an algorithm in the context of programming?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "A function that only runs once"
      },
      {
        "label": "B",
        "type": "text",
        "value": "A set of rules to be followed in calculations or other problem-solving operations"
      },
      {
        "label": "C",
        "type": "text",
        "value": "A type of data structure"
      },
      {
        "label": "D",
        "type": "text",
        "value": "A special kind of software"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "An algorithm is a set of steps or rules to be followed in calculations or problem-solving operations, particularly by a computer."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Binary Trees",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of tree is used specifically for quick search, insertion, and deletion operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "B",
        "type": "text",
        "value": "AVL Tree"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Red-Black Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Segment Tree"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. This property makes AVL trees excellent for quick search, insertion, and deletion operations."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Graphs",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "In graph theory, what does an undirected edge represent?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "A one-way relationship between two nodes"
      },
      {
        "label": "B",
        "type": "text",
        "value": "A two-way, bidirectional relationship between two nodes"
      },
      {
        "label": "C",
        "type": "text",
        "value": "A hierarchical relationship between nodes"
      },
      {
        "label": "D",
        "type": "text",
        "value": "A temporary connection that changes over time"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "An undirected edge in a graph represents a two-way, bidirectional relationship where both nodes connected by the edge can be reached from each other."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Time Complexity",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does the Big O notation generally describe in the context of algorithm analysis?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The worst-case scenario"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The best-case scenario"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The scenario with average complexity"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The space complexity"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O notation describes the upper limit on the running time or space requirement of an algorithm in the worst-case scenario, with respect to the input size."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Algorithm Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which algorithm is specifically designed for sorting and often used for smaller data sets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Insertion Sort is particularly efficient for small data sets and is often chosen for its simplicity where the data is nearly sorted or the data set is small."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Big O notation describe in terms of algorithm complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Upper bound on the running time or memory usage"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Exact running time or memory usage"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Lower bound on the running time or memory usage"
      },
      {
        "label": "D",
        "type": "text",
        "value": "None of the above"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O notation provides an upper limit on the running time or memory usage concerning the input size, describing the worst-case scenario."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Hash Tables",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary operation that hash tables optimize?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Search operations"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Arithmetic operations"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Graph traversal"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Matrix manipulations"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Hash tables are designed to optimize search operations by providing an average-case complexity of O(1) for searches, inserts, and deletes."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is generally considered the fastest for large datasets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Selection Sort"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is generally considered the fastest for large datasets due to its divide and conquer approach, which averages O(n log n) time complexity."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What algorithm is often used for sorting small lists efficiently?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Quick sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Bubble sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Insertion sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Merge sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Insertion sort is often used for sorting small lists because it is simple and has low overhead, making it efficient for lists with a small number of elements."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Arrays",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element by index in an array is a constant time operation, hence the time complexity is O(1)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Problem Solving with Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of algorithm is best suited for sorting a list of names alphabetically?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linear Search"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Search"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Depth First Search"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort is a simple sorting algorithm that is suitable for sorting a list of names alphabetically."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Array Operations",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by index is a constant time operation, hence the time complexity is O(1)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Tree Traversal",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tree traversal method visits the root node before its child nodes?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "In-order"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Post-order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Pre-order"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Level-order"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "In Pre-order traversal, the root node is visited first, followed by the left subtree and then the right subtree."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Graph Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a common way to represent a graph in memory?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Hash table"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Adjacency list"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Queue"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "An adjacency list is a common, efficient way to represent a graph in memory where each vertex (node) stores a list of which vertices it is connected to."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which algorithm is generally preferred for sorting small lists or nearly sorted data efficiently?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort, although generally inefficient, works well for small or nearly sorted lists due to its simplicity and the nature of its comparisons and swaps."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Algorithm Types",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which type of algorithm is primarily used for finding the position of a value within a list?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Sorting algorithm"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Searching algorithm"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Hashing algorithm"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Greedy algorithm"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Searching algorithms are specifically designed to find the position or existence of an element within a list, making them the primary choice for such tasks."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is considered the simplest to understand and implement but inefficient for large data sets?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Heap Sort"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort is considered the simplest sorting algorithm to understand and implement due to its straightforward comparison and swap mechanism. However, it is inefficient for large data sets with its average and worst-case time complexity of O(n^2)."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Algorithm Efficiency",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following sorting algorithms has the best worst-case time complexity?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Merge Sort"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Merge Sort has a guaranteed time complexity of O(n log n) in all cases, making it superior in worst-case scenarios compared to Bubble Sort, Insertion Sort, and Quick Sort with worse or average-case dependent complexities."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm would be effective for a small list of elements?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Radix Sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort, while not efficient for large datasets, is simple and effective for small lists of elements."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Bubble Sort",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the best case time complexity of bubble sort?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n log n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(n^2)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In the best case scenario, where the array is already sorted, bubble sort makes one pass through the array with no swaps, leading to a time complexity of O(n)."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which control structure would be most appropriate for executing a block of code multiple times based on a condition being true?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "While loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "If statement"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Switch statement"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Exit loop"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "While loop continuously executes the code block as long as the condition remains true, making it ideal for repeated execution based on a condition."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Tree Traversal",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tree traversal method visits the root node before its child nodes?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "In-order"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Pre-order"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Post-order"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Level-order"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Pre-order traversal visits the root node first, followed by its left subtree and then the right subtree."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Basic Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a linear data structure?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linked List"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Graph"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Stack"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Graph is not a linear data structure; it is a non-linear data structure. Arrays, linked lists, and stacks are all examples of linear data structures."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Hash Tables",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of a hash function in a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To balance binary trees"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To generate unique keys for storage indices"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To encrypt data"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To sort the data"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "A hash function in a hash table is primarily used to compute an index into an array in which an element will be stored or searched."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Algorithm Efficiency",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following algorithms is generally fastest on large data sets for sorting?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Selection Sort"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is generally faster than Bubble Sort, Insertion Sort, and Selection Sort for large data sets due to its divide and conquer approach."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of these algorithms is typically known for having a time complexity of O(n^2)?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Insertion Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Merge Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Search"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Insertion Sort has a worst-case time complexity of O(n^2), which occurs when the input data is in reverse order."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Searching Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of data structure is required for binary search to be applicable?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Unsorted array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sorted array"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Linked list"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Hash table"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search requires a sorted array to function properly. The algorithm continually divides the search interval in half, which relies on the elements being sorted to correctly determine the direction of the search."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Big O notation describe in the context of algorithm analysis?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The worst-case upper limit on the running time or memory usage"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The best-case scenario performance"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The average-case scenario performance"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The exact running time regardless of input size"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O notation is used to provide an upper limit on the running time or memory usage of an algorithm, representing the worst-case scenario as input size grows."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Graph Traversal",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which graph traversal method visits all the nodes in a layer before moving to the next layer?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Depth-First Search (DFS)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Breadth-First Search (BFS)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "In-Order Traversal"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Pre-Order Traversal"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Breadth-First Search (BFS) visits all the nodes in a layer-wise fashion before moving to the next layer."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is not a looping structure in most programming languages?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "for"
      },
      {
        "label": "B",
        "type": "text",
        "value": "while"
      },
      {
        "label": "C",
        "type": "text",
        "value": "if"
      },
      {
        "label": "D",
        "type": "text",
        "value": "do-while"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The 'if' statement is a conditional structure, not a looping structure."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Hash Tables",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of a hash function in a hash table?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To generate a unique index for storing keys"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To encrypt data"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To extend array size automatically"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To create a backup of the data"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A hash function in a hash table is used to compute an index into an array of buckets or slots, from which the desired value can be found."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which sorting algorithm is generally considered the fastest in most scenarios?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Quick Sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Selection Sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Insertion Sort"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Quick Sort is generally considered the fastest sorting algorithm in most scenarios due to its average and worst-case time complexities of O(n log n)."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Time Complexity Analysis",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element in an array by index is a constant time operation, hence the time complexity is O(1)."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Tree Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which tree data structure is generally used for faster search, insert, and delete operations?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "B",
        "type": "text",
        "value": "AVL Tree"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Red-Black Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Binary Search Tree"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. This self-balancing property leads to faster search, insert, and delete operations."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Basic Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does an algorithm typically aim to achieve?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To create a visual representation of data"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To solve a problem using a step-by-step procedure"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To increase the complexity of a program"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To reduce the efficiency of data processing"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "An algorithm is a set of steps designed to solve a problem or perform a specific task."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Binary Search",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following conditions must be met for binary search to be applicable?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The array must be sorted in ascending order."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The array must have unique elements."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The array must contain numeric values only."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The array must be of fixed length."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search requires the array to be sorted in ascending order to divide and check subarrays effectively."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a type of data structure?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Queue"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Variable"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Queue, Stack, and Linked List are all common data structures, whereas 'Variable' is a term used in programming to denote a storage location paired with an associated symbolic name, which contains some known or unknown quantity or information, a value."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Arrays",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the time complexity of accessing an element in an array by index?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "O(1)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "O(n)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "O(log n)"
      },
      {
        "label": "D",
        "type": "text",
        "value": "O(n log n)"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Accessing an element by index in an array is a direct operation and thus has a time complexity of O(1)."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is a common algorithm used to sort a list of elements in ascending order?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble Sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linear Search"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Search"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Hash Table"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. This process is repeated until the list is sorted in ascending order."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Basic Data Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is NOT a type of linear data structure?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Queue"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Stack"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "A Tree is a non-linear data structure compared to Queue, Stack, and Linked List which are linear."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Big O Notation",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What does Big O Notation describe in algorithm analysis?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The worst-case scenario of the algorithm's running time or space requirement."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The best-case scenario of the algorithm's performance."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The algorithm's performance on average data input."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The hardware requirements for running the algorithm."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Big O Notation provides an upper limit on the running time or memory usage concerning the input size, describing the worst-case scenario."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Sorting Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is not a comparison-based sorting algorithm?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Bubble sort"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Merge sort"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Quick sort"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Counting sort"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Counting sort is a non-comparison-based sorting algorithm that sorts elements by counting the number of occurrences of each unique value."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Searching Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What type of data structure is required for binary search to be applicable?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Unsorted Array"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Sorted Array"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Binary Tree"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Linked List"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search requires a sorted array to function properly, as it repeatedly divides the search interval in half."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Hash Table Operations",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is the primary operation that hash tables optimize?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Sorting"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Data retrieval"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Data visualization"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Data serialization"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Hash tables optimize data retrieval by providing a means to access data in constant time under ideal conditions."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Control Structures",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which control structure is typically used for iterating through an array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "for loop"
      },
      {
        "label": "B",
        "type": "text",
        "value": "if statement"
      },
      {
        "label": "C",
        "type": "text",
        "value": "switch case"
      },
      {
        "label": "D",
        "type": "text",
        "value": "try catch block"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "A for loop is typically used for iterating through the elements of an array by incrementing a counter until a specified condition is met."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Binary Search",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "What is a prerequisite for a binary search algorithm to work effectively on an array?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The array must be sorted"
      },
      {
        "label": "B",
        "type": "text",
        "value": "The array must have unique elements"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The array must be of even length"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The array must be multidimensional"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Binary search operates by repeatedly dividing the search interval in half, which requires the array to be sorted to correctly determine the direction of the search."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Graphs",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a common way to represent a graph in memory?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Adjacency list"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Linked list"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Hash map"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Queue"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "An adjacency list is a common way to represent a graph in memory since it efficiently lists all the vertices that are directly connected to each vertex."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Searching Algorithms",
    "difficulty": "easy",
    "question": [
      {
        "type": "text",
        "value": "Which algorithm is particularly efficient when the data is already sorted?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Linear Search"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Binary Search"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Depth-First Search"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Breadth-First Search"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Binary Search is highly efficient for sorted data with a time complexity of O(log n), as it repeatedly divides the search interval in half."
      }
    ]
  }
]