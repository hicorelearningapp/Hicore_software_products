[
  {
    "id": 2,
    "topic": "React Context API",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which component is used in React's Context API to provide a context value to all components within the tree that it wraps?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Context.Provider"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Context.Consumer"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Context.Wrapper"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Context.Dispatcher"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Context.Provider is the component used in the Context API to pass down the context value to the tree of components it wraps, allowing them to consume that context."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Environment Variables in React",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which file is used to define environment variables in a React application for different deployment environments?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": ".env.production"
      },
      {
        "label": "B",
        "type": "text",
        "value": "webpack.config.js"
      },
      {
        "label": "C",
        "type": "text",
        "value": "package.json"
      },
      {
        "label": "D",
        "type": "text",
        "value": "react.config.js"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Environment-specific variables are defined in files like '.env.production' for production environments, allowing different settings per deployment environment."
      }
    ]
  },
  {
    "id": 4,
    "topic": "useEffect for Side Effects",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is a common use case for the useEffect hook in a React component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To type-check props"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To directly mutate the DOM"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To perform side effects in component"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To pass data between components"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "useEffect is primarily used to handle side effects in functional components, such as API calls, subscriptions, or manually manipulating the DOM."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Props vs State",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following statements is true about props and state in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Props are mutable and state is immutable."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Props are immutable and can be used to store data that changes over time."
      },
      {
        "label": "C",
        "type": "text",
        "value": "State is local and owned by the component whereas props get passed to the component."
      },
      {
        "label": "D",
        "type": "text",
        "value": "State can be passed to child components as props."
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "State is local to the component and specifically owned by it, used to control the component's behavior and render. Props, on the other hand, are passed to the component by its parent and are meant to configure or provide data to it."
      }
    ]
  },
  {
    "id": 7,
    "topic": "useState Hook",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which statement is true regarding the initialization of state in a functional component using the useState hook?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The initial state can only be an object."
      },
      {
        "label": "B",
        "type": "text",
        "value": "The useState hook returns an array with two elements."
      },
      {
        "label": "C",
        "type": "text",
        "value": "The useState hook accepts two arguments for initial state and a function."
      },
      {
        "label": "D",
        "type": "text",
        "value": "The initial state is always undefined."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The useState hook initializes state in a functional component and returns an array with two elements: the current state and a function that updates it."
      }
    ]
  },
  {
    "id": 5,
    "topic": "State Management in Functional Components",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which hook would be suitable for managing state in a functional component in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "useState"
      },
      {
        "label": "B",
        "type": "text",
        "value": "useEffect"
      },
      {
        "label": "C",
        "type": "text",
        "value": "useReducer"
      },
      {
        "label": "D",
        "type": "text",
        "value": "useContext"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "useState is the primary hook used for adding local state to functional components, allowing the components to maintain internal state."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Component Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in a React Class component is commonly used for setting up subscriptions or fetching data?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidCatch()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidMount()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentWillUnmount()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "shouldComponentUpdate()"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "componentDidMount() is used for setting up subscriptions or fetching data as it is called immediately after a component is mounted, making it the perfect place to initiate network requests or integrate with other JavaScript frameworks."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Debugging Techniques",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which tool is integral for debugging React applications for state management and component hierarchy issues?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "React Developer Tools"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Chrome DevTools"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Jest"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Webpack"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "React Developer Tools is a browser extension specifically designed for debugging React applications, allowing developers to inspect component hierarchies, observe component state and props, and more."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Component Testing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What tool is primarily used for testing React components by rendering them in a virtual DOM?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Jest"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Mocha"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Enzyme"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Cypress"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Enzyme is specifically designed for testing React components by rendering them in a virtual DOM, allowing for shallow rendering and full DOM rendering."
      }
    ]
  },
  {
    "id": 8,
    "topic": "State and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary difference between state and props in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Props are immutable and state can be changed."
      },
      {
        "label": "B",
        "type": "text",
        "value": "State can't be passed to child components, but props can."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Props are used to store data, while state is used to render components."
      },
      {
        "label": "D",
        "type": "text",
        "value": "There is no difference, both are used interchangeably."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Props (short for properties) are read-only and are passed to the component (similar to function parameters) whereas state is managed within the component (similar to variables declared within a function)."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Dynamic Routing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of the 'Route' component in React Router?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To configure a new route path and its corresponding component"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To link to different parts of the application"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To handle state management within the application"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To optimize the rendering performance of the application"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The 'Route' component is used in React Router to define paths in the URL that correspond to different components, allowing for navigation and rendering of specific components based on the URL."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Snapshot Testing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is a key benefit of using snapshot testing in React applications?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It automatically fixes bugs in the code."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It ensures that UI does not change unexpectedly."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It speeds up the performance of React applications."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It eliminates the need for other types of testing."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Snapshot testing allows developers to ensure their UI does not change unexpectedly by comparing previous snapshots with current ones."
      }
    ]
  },
  {
    "id": 3,
    "topic": "React Testing Library",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which function is used to clean up after each test in React Testing Library to remove components from the DOM?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "cleanup()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "remove()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "detach()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "dismiss()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The cleanup() function is used after each test to unmount tree that was mounted with the render function."
      }
    ]
  },
  {
    "id": 1,
    "topic": "React Component Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in a React Class component is called when the component is first mounted to the DOM?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidUpdate"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "D",
        "type": "text",
        "value": "shouldComponentUpdate"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "componentDidMount is called as soon as the component is mounted and ready. This is a good place to initiate API calls, if you need to load data from a remote endpoint."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Debugging Techniques",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In React development, which tool is commonly used to debug and inspect the React component hierarchy?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "React Developer Tools"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Chrome Developer Tools"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Visual Studio Code"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Safari Developer Tools"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "React Developer Tools is a browser extension specifically designed for debugging React applications. It allows developers to observe component hierarchies, inspect component props and state, and more."
      }
    ]
  },
  {
    "id": 5,
    "topic": "React Components",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the correct method to set a state value when the new state depends on the previous state in a React functional component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "setState(newState)"
      },
      {
        "label": "B",
        "type": "text",
        "value": "setState(prevState => newState)"
      },
      {
        "label": "C",
        "type": "text",
        "value": "this.setState({state: newState})"
      },
      {
        "label": "D",
        "type": "text",
        "value": "setState(prevState => ({...prevState, ...newState}))"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "When setting a state that depends on the previous state in a functional component, the correct approach is to use a function that receives the previous state and returns the new state object. This ensures the state updates correctly in response to asynchronous state updates."
      }
    ]
  },
  {
    "id": 2,
    "topic": "useEffect for Side Effects",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which dependency list should be used in the useEffect hook to ensure it runs only once when the component mounts?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "An empty object {}"
      },
      {
        "label": "B",
        "type": "text",
        "value": "No dependency list"
      },
      {
        "label": "C",
        "type": "text",
        "value": "An empty array []"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The state variable used inside useEffect"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Option C is correct because providing an empty array as the dependency list ensures that the effect runs only once after the initial render."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Deployment",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which service is not commonly used to deploy a production build of a React application?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Vercel"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Netlify"
      },
      {
        "label": "C",
        "type": "text",
        "value": "GitHub Pages"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Microsoft Excel"
      }
    ],
    "correct": "D",
    "explanation": [
      {
        "type": "text",
        "value": "Microsoft Excel is not a deployment service; it is a spreadsheet application. Vercel, Netlify, and GitHub Pages are commonly used for deploying React applications."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Basic Routing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What component in React Router v6 is used to define the mapping between the URL and your route component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "BrowserRouter"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Routes"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Link"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Route"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In React Router v6, the 'Routes' component is used to define the mapping of URLs to components, replacing the 'Switch' component used in previous versions."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Components and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which of the following is true about functional components in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "They cannot manage their own state."
      },
      {
        "label": "B",
        "type": "text",
        "value": "They do not accept props."
      },
      {
        "label": "C",
        "type": "text",
        "value": "They must be written as ES6 classes."
      },
      {
        "label": "D",
        "type": "text",
        "value": "They are deprecated in React."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Functional components are stateless by definition but can manage state using hooks."
      }
    ]
  },
  {
    "id": 10,
    "topic": "State and Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in Class components is commonly used to fetch data in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentWillMount"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentDidUpdate"
      },
      {
        "label": "D",
        "type": "text",
        "value": "shouldComponentUpdate"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The componentDidMount lifecycle method is typically used to fetch data in Class components as it is called after the component is rendered, making it safe to perform side effects like data fetching."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Component Testing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of using shallow rendering in React component testing?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To test components in isolation from their child components"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To fully render the parent and child components"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To check the integration between multiple components"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To interact with APIs"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Shallow rendering is used to test a component in isolation without worrying about the behavior of child components, which are not instantiated or rendered in shallow rendering mode."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Environment Setup",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which command initializes a new React project with a specific template?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "npx create-react-app my-app"
      },
      {
        "label": "B",
        "type": "text",
        "value": "npx create-react-app my-app --template typescript"
      },
      {
        "label": "C",
        "type": "text",
        "value": "npm install react"
      },
      {
        "label": "D",
        "type": "text",
        "value": "react new --template basic"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The correct command to initialize a new React project with a TypeScript template is 'npx create-react-app my-app --template typescript'."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Effect of useEffect",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What does the useEffect hook do in a functional component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It manages the component lifecycle and side effects."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It updates the component state directly."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It creates a new component each render."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It returns the initial state of the component."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "useEffect is used to manage side effects in functional components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in class components, allowing you to perform side effects and synchronize the component with external data sources."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Debugging in React",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What React tool can be used to inspect and modify the state of React components in a running app?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "React Developer Tools"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Redux DevTools"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Chrome DevTools"
      },
      {
        "label": "D",
        "type": "text",
        "value": "React State Viewer"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "React Developer Tools is a browser extension for Chrome and Firefox that provides an inspector interface for React components, allowing you to view and edit their current props and state."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Lifecycle Methods",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in React is called right before the component is removed from the DOM?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidUpdate"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "D",
        "type": "text",
        "value": "shouldComponentUpdate"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "componentWillUnmount is called immediately before a component is destroyed and removed from the DOM, allowing for cleanup operations."
      }
    ]
  },
  {
    "id": 6,
    "topic": "State and Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in React is commonly used for making AJAX requests?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "constructor()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidMount()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "shouldComponentUpdate()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "componentWillUnmount()"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The componentDidMount() lifecycle method is ideal for making AJAX requests as it is called after the component is mounted and has a DOM representation."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Route Parameters",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "How do you access URL parameters in a component in React Router v6?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Using the useParams hook"
      },
      {
        "label": "B",
        "type": "text",
        "value": "With the useHistory hook"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Through props.match.params"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Via the useLocation hook"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In React Router v6, the useParams hook is used to access the URL parameters within a component, which is an update from using props.match.params in previous versions."
      }
    ]
  },
  {
    "id": 4,
    "topic": "Route Configuration",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the purpose of the <Routes> component in React Router?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To link to different paths"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To configure parent and child routes"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To navigate programmatically to different routes"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To pass props to route components"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The <Routes> component is used to configure parent and child routes in a React application using React Router."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Component Testing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What method is commonly used for testing React components to ensure they render correctly?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "snapshot testing"
      },
      {
        "label": "B",
        "type": "text",
        "value": "end-to-end testing"
      },
      {
        "label": "C",
        "type": "text",
        "value": "stress testing"
      },
      {
        "label": "D",
        "type": "text",
        "value": "load testing"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Snapshot testing is commonly used for testing React components to ensure they render correctly by comparing the current render output with a previously stored 'snapshot'."
      }
    ]
  },
  {
    "id": 1,
    "topic": "State and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What will happen if you try to change props in a React component directly?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "The component will re-render with new props"
      },
      {
        "label": "B",
        "type": "text",
        "value": "React will throw an error"
      },
      {
        "label": "C",
        "type": "text",
        "value": "The changes will be ignored and no error will be shown"
      },
      {
        "label": "D",
        "type": "text",
        "value": "The parent component will update its own props"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "Props are read-only. If you try to change their value directly inside a component, React will not re-render the component, and it will not alter the props but continue with the initial props value."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Props and State",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary difference between props and state in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Props are mutable while state is immutable."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Props are immutable while state is mutable."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Both props and state are immutable."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Both props and state are mutable."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Props are read-only and are set by the parent component, while state is mutable and managed within the component itself."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Components and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of props in React components?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To maintain internal state"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To pass data and event handlers to components"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To enhance CSS styling"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To perform complex computations"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Props are used in React to pass data and event handlers down to child components from a parent component. They are essential for component reusability and composition."
      }
    ]
  },
  {
    "id": 8,
    "topic": "useEffect Hook",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What does the useEffect hook do in a functional component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It manages the component's state and lifecycle."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It only fetches data when the component mounts."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It renders the UI based on dependencies."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It is used strictly for computational purposes."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The useEffect hook is used to perform side effects in functional components. It can handle state and lifecycle features similar to componentDidMount, componentDidUpdate, and componentWillUnmount in class components."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Components and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is a key property in a list of React components primarily used for?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To enhance CSS styling."
      },
      {
        "label": "B",
        "type": "text",
        "value": "To ensure components are unique and re-render efficiently."
      },
      {
        "label": "C",
        "type": "text",
        "value": "To store data externally."
      },
      {
        "label": "D",
        "type": "text",
        "value": "To encrypt component data."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The key property helps React identify which items have changed, are added, or are removed, which aids in efficient updates to the user interface."
      }
    ]
  },
  {
    "id": 6,
    "topic": "Lifecycle Methods",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method should you use to send a network request when a component is first mounted?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "shouldComponentUpdate"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "D",
        "type": "text",
        "value": "componentDidUpdate"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The componentDidMount lifecycle method is ideal for network requests as it is called only once in the lifecycle of a component, immediately after it is inserted into the tree."
      }
    ]
  },
  {
    "id": 5,
    "topic": "Components and Props",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In React, what is the correct way to pass a prop from a parent component to a child component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "<ChildComponent prop={value} />"
      },
      {
        "label": "B",
        "type": "text",
        "value": "<ChildComponent>{value}</ChildComponent>"
      },
      {
        "label": "C",
        "type": "text",
        "value": "<ChildComponent value={prop} />"
      },
      {
        "label": "D",
        "type": "text",
        "value": "<ChildComponent value='prop' />"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In React, props are passed from a parent component to a child component using attributes in the child component tag, with the syntax <ChildComponent prop={value} />."
      }
    ]
  },
  {
    "id": 7,
    "topic": "JSX Basics",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the correct syntax for embedding JavaScript expressions within JSX?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "<div>{expression}</div>"
      },
      {
        "label": "B",
        "type": "text",
        "value": "<div>expression</div>"
      },
      {
        "label": "C",
        "type": "text",
        "value": "<div>${expression}</div>"
      },
      {
        "label": "D",
        "type": "text",
        "value": "<div>(expression)</div>"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "In JSX, JavaScript expressions must be wrapped in curly braces."
      }
    ]
  },
  {
    "id": 2,
    "topic": "State and Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in a Class component is commonly used to fetch data in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "shouldComponentUpdate"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "D",
        "type": "text",
        "value": "getDerivedStateFromProps"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "componentDidMount is the lifecycle method in Class components where you can perform side effects, such as data fetching, setting up subscriptions, and more."
      }
    ]
  },
  {
    "id": 3,
    "topic": "Class Components",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method in React Class Components is called immediately after a component is mounted?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidMount()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentWillMount()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentDidUpdate()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "componentWillUnmount()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "componentDidMount() is the correct answer because it is called immediately after the component is mounted and is used to trigger updates to the component."
      }
    ]
  },
  {
    "id": 8,
    "topic": "Navigation",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the purpose of the <Navigate> component in React Router?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To create a new route path"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To link to external websites"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To redirect to a different route"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To pass props to child components"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "The <Navigate> component in React Router is used to redirect from one route to another, replacing one entry in the history stack with another."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Props vs State",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary difference between props and state in React?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "Props are mutable and state is immutable."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Props are immutable and state is mutable."
      },
      {
        "label": "C",
        "type": "text",
        "value": "Both props and state are immutable."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Both props and state are mutable."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "Props are immutable and passed from parent to child component, whereas state is mutable and managed within the component."
      }
    ]
  },
  {
    "id": 10,
    "topic": "Effectively Using useEffect",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What does the useEffect hook do in a functional component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "It allows you to perform side effects in your component."
      },
      {
        "label": "B",
        "type": "text",
        "value": "It lets you change the state of the component directly."
      },
      {
        "label": "C",
        "type": "text",
        "value": "It replaces the need for importing React into your component."
      },
      {
        "label": "D",
        "type": "text",
        "value": "It optimizes the performance by preventing re-renders."
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because useEffect is used for handling side effects necessary for the component, such as data fetching, setting up a subscription, or manually changing the DOM."
      }
    ]
  },
  {
    "id": 9,
    "topic": "Using useState in Functional Components",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the correct way to set an initial state using the useState hook in a functional component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "const [state, setState] = useState(initialState);"
      },
      {
        "label": "B",
        "type": "text",
        "value": "const state = useState(initialState);"
      },
      {
        "label": "C",
        "type": "text",
        "value": "useState = (initialState) => [state, setState];"
      },
      {
        "label": "D",
        "type": "text",
        "value": "setState(initialState);"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "Option A is correct because it uses the useState hook to initialize 'state' with 'initialState' and provides 'setState' function to update the state."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Component Lifecycle Methods",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method is called when a component is being removed from the DOM?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentDidUpdate"
      },
      {
        "label": "D",
        "type": "text",
        "value": "componentWillMount"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "componentWillUnmount is used to clean up any subscriptions, timers, or other ongoing operations to prevent memory leaks when the component is removed from the DOM."
      }
    ]
  },
  {
    "id": 7,
    "topic": "Route Parameters",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In React Router v6, which hook is used to access the route parameters?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "useParams()"
      },
      {
        "label": "B",
        "type": "text",
        "value": "useRouter()"
      },
      {
        "label": "C",
        "type": "text",
        "value": "useRoute()"
      },
      {
        "label": "D",
        "type": "text",
        "value": "useNavigation()"
      }
    ],
    "correct": "A",
    "explanation": [
      {
        "type": "text",
        "value": "The useParams() hook is used in React Router v6 to access the match.params of the current <Route>."
      }
    ]
  },
  {
    "id": 4,
    "topic": "State and Lifecycle",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "In React, how can you update the state of a component?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "By directly modifying the this.state object."
      },
      {
        "label": "B",
        "type": "text",
        "value": "Using the this.setState() method."
      },
      {
        "label": "C",
        "type": "text",
        "value": "By reloading the component."
      },
      {
        "label": "D",
        "type": "text",
        "value": "Using an external library."
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "In React, the correct way to update a component's state is by using the this.setState() method, as it schedules an update to the component's state object and tells React that this component and its children need to re-render with the updated state."
      }
    ]
  },
  {
    "id": 2,
    "topic": "Lifecycle Methods",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "Which lifecycle method is invoked right before a component is unmounted and destroyed?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "componentDidMount"
      },
      {
        "label": "B",
        "type": "text",
        "value": "componentDidUpdate"
      },
      {
        "label": "C",
        "type": "text",
        "value": "componentWillUnmount"
      },
      {
        "label": "D",
        "type": "text",
        "value": "shouldComponentUpdate"
      }
    ],
    "correct": "C",
    "explanation": [
      {
        "type": "text",
        "value": "componentWillUnmount is the lifecycle method that is called just before a component is unmounted and destroyed, perfect for cleaning up operations."
      }
    ]
  },
  {
    "id": 1,
    "topic": "Basic Routing",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What component in React Router v5 is used to define a route that will render a component based on the URL path?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "BrowserRouter"
      },
      {
        "label": "B",
        "type": "text",
        "value": "Route"
      },
      {
        "label": "C",
        "type": "text",
        "value": "Link"
      },
      {
        "label": "D",
        "type": "text",
        "value": "Switch"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The 'Route' component is used in React Router v5 to define routes that render different UI components based on the URL path."
      }
    ]
  },
  {
    "id": 3,
    "topic": "useState in Functional Components",
    "difficulty": "medium",
    "question": [
      {
        "type": "text",
        "value": "What is the primary purpose of the useState hook in React functional components?"
      }
    ],
    "options": [
      {
        "label": "A",
        "type": "text",
        "value": "To connect to external APIs"
      },
      {
        "label": "B",
        "type": "text",
        "value": "To manage state in a functional component"
      },
      {
        "label": "C",
        "type": "text",
        "value": "To navigate between different components"
      },
      {
        "label": "D",
        "type": "text",
        "value": "To enhance rendering performance"
      }
    ],
    "correct": "B",
    "explanation": [
      {
        "type": "text",
        "value": "The useState hook is used to add local state management to functional components, allowing them to maintain and update state over time."
      }
    ]
  }
]